// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fs.proto

package proto

import (
        fmt "fmt"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/golang/protobuf/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Dentry struct {
        ParentId uint64 `protobuf:"varint,1,opt,name=ParentId,proto3" json:"pid"`
        Name     string `protobuf:"bytes,2,opt,name=Name,proto3" json:"name"`
        Inode    uint64 `protobuf:"varint,3,opt,name=Inode,proto3" json:"ino"`
        Type     uint32 `protobuf:"varint,4,opt,name=Type,proto3" json:"type"`
}

func (m *Dentry) Reset()         { *m = Dentry{} }
func (m *Dentry) String() string { return proto.CompactTextString(m) }
func (*Dentry) ProtoMessage()    {}
func (*Dentry) Descriptor() ([]byte, []int) {
        return fileDescriptor_e604833c2b457e38, []int{0}
}
func (m *Dentry) XXX_Unmarshal(b []byte) error {
        return m.Unmarshal(b)
}
func (m *Dentry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
        if deterministic {
                return xxx_messageInfo_Dentry.Marshal(b, m, deterministic)
        } else {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil {
                        return nil, err
                }
                return b[:n], nil
        }
}
func (m *Dentry) XXX_Merge(src proto.Message) {
        xxx_messageInfo_Dentry.Merge(m, src)
}
func (m *Dentry) XXX_Size() int {
        return m.Size()
}
func (m *Dentry) XXX_DiscardUnknown() {
        xxx_messageInfo_Dentry.DiscardUnknown(m)
}

var xxx_messageInfo_Dentry proto.InternalMessageInfo

func (m *Dentry) GetParentId() uint64 {
        if m != nil {
                return m.ParentId
        }
        return 0
}

func (m *Dentry) GetName() string {
        if m != nil {
                return m.Name
        }
        return ""
}

func (m *Dentry) GetInode() uint64 {
        if m != nil {
                return m.Inode
        }
        return 0
}

func (m *Dentry) GetType() uint32 {
        if m != nil {
                return m.Type
        }
        return 0
}

type ReadDirRequest struct {
        VolName     string `protobuf:"bytes,1,opt,name=VolName,proto3" json:"vol"`
        PartitionID uint64 `protobuf:"varint,2,opt,name=PartitionID,proto3" json:"pid"`
        ParentID    uint64 `protobuf:"varint,3,opt,name=ParentID,proto3" json:"pino"`
        Marker      string `protobuf:"bytes,4,opt,name=Marker,proto3" json:"marker"`
        IsBatch     bool   `protobuf:"varint,5,opt,name=IsBatch,proto3" json:"is_batch"`
}

func (m *ReadDirRequest) Reset()         { *m = ReadDirRequest{} }
func (m *ReadDirRequest) String() string { return proto.CompactTextString(m) }
func (*ReadDirRequest) ProtoMessage()    {}
func (*ReadDirRequest) Descriptor() ([]byte, []int) {
        return fileDescriptor_e604833c2b457e38, []int{1}
}
func (m *ReadDirRequest) XXX_Unmarshal(b []byte) error {
        return m.Unmarshal(b)
}
func (m *ReadDirRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
        if deterministic {
                return xxx_messageInfo_ReadDirRequest.Marshal(b, m, deterministic)
        } else {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil {
                        return nil, err
                }
                return b[:n], nil
        }
}
func (m *ReadDirRequest) XXX_Merge(src proto.Message) {
        xxx_messageInfo_ReadDirRequest.Merge(m, src)
}
func (m *ReadDirRequest) XXX_Size() int {
        return m.Size()
}
func (m *ReadDirRequest) XXX_DiscardUnknown() {
        xxx_messageInfo_ReadDirRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadDirRequest proto.InternalMessageInfo

func (m *ReadDirRequest) GetVolName() string {
        if m != nil {
                return m.VolName
        }
        return ""
}

func (m *ReadDirRequest) GetPartitionID() uint64 {
        if m != nil {
                return m.PartitionID
        }
        return 0
}

func (m *ReadDirRequest) GetParentID() uint64 {
        if m != nil {
                return m.ParentID
        }
        return 0
}

func (m *ReadDirRequest) GetMarker() string {
        if m != nil {
                return m.Marker
        }
        return ""
}

func (m *ReadDirRequest) GetIsBatch() bool {
        if m != nil {
                return m.IsBatch
        }
        return false
}

type ReadDirResponse struct {
        Children   []Dentry `protobuf:"bytes,1,rep,name=Children,proto3" json:"children"`
        NextMarker string   `protobuf:"bytes,2,opt,name=NextMarker,proto3" json:"next_marker"`
}

func (m *ReadDirResponse) Reset()         { *m = ReadDirResponse{} }
func (m *ReadDirResponse) String() string { return proto.CompactTextString(m) }
func (*ReadDirResponse) ProtoMessage()    {}
func (*ReadDirResponse) Descriptor() ([]byte, []int) {
        return fileDescriptor_e604833c2b457e38, []int{2}
}
func (m *ReadDirResponse) XXX_Unmarshal(b []byte) error {
        return m.Unmarshal(b)
}
func (m *ReadDirResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
        if deterministic {
                return xxx_messageInfo_ReadDirResponse.Marshal(b, m, deterministic)
        } else {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil {
                        return nil, err
                }
                return b[:n], nil
        }
}
func (m *ReadDirResponse) XXX_Merge(src proto.Message) {
        xxx_messageInfo_ReadDirResponse.Merge(m, src)
}
func (m *ReadDirResponse) XXX_Size() int {
        return m.Size()
}
func (m *ReadDirResponse) XXX_DiscardUnknown() {
        xxx_messageInfo_ReadDirResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReadDirResponse proto.InternalMessageInfo

func (m *ReadDirResponse) GetChildren() []Dentry {
        if m != nil {
                return m.Children
        }
        return nil
}

func (m *ReadDirResponse) GetNextMarker() string {
        if m != nil {
                return m.NextMarker
        }
        return ""
}

type InodeInfoPb struct {
        Inode      uint64     `protobuf:"varint,1,opt,name=Inode,proto3" json:"ino"`
        Mode       uint32     `protobuf:"varint,2,opt,name=Mode,proto3" json:"mode"`
        Nlink      uint32     `protobuf:"varint,3,opt,name=Nlink,proto3" json:"nlink"`
        Size_      uint64     `protobuf:"varint,4,opt,name=Size,proto3" json:"sz"`
        Uid        uint32     `protobuf:"varint,5,opt,name=Uid,proto3" json:"uid"`
        Gid        uint32     `protobuf:"varint,6,opt,name=Gid,proto3" json:"gid"`
        Generation uint64     `protobuf:"varint,7,opt,name=Generation,proto3" json:"gen"`
        ModifyTime CubeFSTime `protobuf:"varint,8,opt,name=ModifyTime,proto3,customtype=CubeFSTime" json:"mt"`
        CreateTime CubeFSTime `protobuf:"varint,9,opt,name=CreateTime,proto3,customtype=CubeFSTime" json:"ct"`
        AccessTime CubeFSTime `protobuf:"varint,10,opt,name=AccessTime,proto3,customtype=CubeFSTime" json:"at"`
        Target     []byte     `protobuf:"bytes,11,opt,name=Target,proto3" json:"tgt"`
}

func (m *InodeInfoPb) Reset()         { *m = InodeInfoPb{} }
func (m *InodeInfoPb) String() string { return proto.CompactTextString(m) }
func (*InodeInfoPb) ProtoMessage()    {}
func (*InodeInfoPb) Descriptor() ([]byte, []int) {
        return fileDescriptor_e604833c2b457e38, []int{3}
}
func (m *InodeInfoPb) XXX_Unmarshal(b []byte) error {
        return m.Unmarshal(b)
}
func (m *InodeInfoPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
        if deterministic {
                return xxx_messageInfo_InodeInfoPb.Marshal(b, m, deterministic)
        } else {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil {
                        return nil, err
                }
                return b[:n], nil
        }
}
func (m *InodeInfoPb) XXX_Merge(src proto.Message) {
        xxx_messageInfo_InodeInfoPb.Merge(m, src)
}
func (m *InodeInfoPb) XXX_Size() int {
        return m.Size()
}
func (m *InodeInfoPb) XXX_DiscardUnknown() {
        xxx_messageInfo_InodeInfoPb.DiscardUnknown(m)
}

var xxx_messageInfo_InodeInfoPb proto.InternalMessageInfo

func (m *InodeInfoPb) GetInode() uint64 {
        if m != nil {
                return m.Inode
        }
        return 0
}

func (m *InodeInfoPb) GetMode() uint32 {
        if m != nil {
                return m.Mode
        }
        return 0
}

func (m *InodeInfoPb) GetNlink() uint32 {
        if m != nil {
                return m.Nlink
        }
        return 0
}

func (m *InodeInfoPb) GetSize_() uint64 {
        if m != nil {
                return m.Size_
        }
        return 0
}

func (m *InodeInfoPb) GetUid() uint32 {
        if m != nil {
                return m.Uid
        }
        return 0
}

func (m *InodeInfoPb) GetGid() uint32 {
        if m != nil {
                return m.Gid
        }
        return 0
}

func (m *InodeInfoPb) GetGeneration() uint64 {
        if m != nil {
                return m.Generation
        }
        return 0
}

func (m *InodeInfoPb) GetTarget() []byte {
        if m != nil {
                return m.Target
        }
        return nil
}

type ExtendAttrInfoPb struct {
        Name  string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
        Value string `protobuf:"bytes,2,opt,name=Value,proto3" json:"value"`
}

func (m *ExtendAttrInfoPb) Reset()         { *m = ExtendAttrInfoPb{} }
func (m *ExtendAttrInfoPb) String() string { return proto.CompactTextString(m) }
func (*ExtendAttrInfoPb) ProtoMessage()    {}
func (*ExtendAttrInfoPb) Descriptor() ([]byte, []int) {
        return fileDescriptor_e604833c2b457e38, []int{4}
}
func (m *ExtendAttrInfoPb) XXX_Unmarshal(b []byte) error {
        return m.Unmarshal(b)
}
func (m *ExtendAttrInfoPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
        if deterministic {
                return xxx_messageInfo_ExtendAttrInfoPb.Marshal(b, m, deterministic)
        } else {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil {
                        return nil, err
                }
                return b[:n], nil
        }
}
func (m *ExtendAttrInfoPb) XXX_Merge(src proto.Message) {
        xxx_messageInfo_ExtendAttrInfoPb.Merge(m, src)
}
func (m *ExtendAttrInfoPb) XXX_Size() int {
        return m.Size()
}
func (m *ExtendAttrInfoPb) XXX_DiscardUnknown() {
        xxx_messageInfo_ExtendAttrInfoPb.DiscardUnknown(m)
}

var xxx_messageInfo_ExtendAttrInfoPb proto.InternalMessageInfo

func (m *ExtendAttrInfoPb) GetName() string {
        if m != nil {
                return m.Name
        }
        return ""
}

func (m *ExtendAttrInfoPb) GetValue() string {
        if m != nil {
                return m.Value
        }
        return ""
}

type InodeExtendAttrsInfoPb struct {
        InodeID     uint64              `protobuf:"varint,1,opt,name=InodeID,proto3" json:"ino"`
        ExtendAttrs []*ExtendAttrInfoPb `protobuf:"bytes,2,rep,name=ExtendAttrs,proto3" json:"extendAttrs"`
}

func (m *InodeExtendAttrsInfoPb) Reset()         { *m = InodeExtendAttrsInfoPb{} }
func (m *InodeExtendAttrsInfoPb) String() string { return proto.CompactTextString(m) }
func (*InodeExtendAttrsInfoPb) ProtoMessage()    {}
func (*InodeExtendAttrsInfoPb) Descriptor() ([]byte, []int) {
        return fileDescriptor_e604833c2b457e38, []int{5}
}
func (m *InodeExtendAttrsInfoPb) XXX_Unmarshal(b []byte) error {
        return m.Unmarshal(b)
}
func (m *InodeExtendAttrsInfoPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
        if deterministic {
                return xxx_messageInfo_InodeExtendAttrsInfoPb.Marshal(b, m, deterministic)
        } else {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil {
                        return nil, err
                }
                return b[:n], nil
        }
}
func (m *InodeExtendAttrsInfoPb) XXX_Merge(src proto.Message) {
        xxx_messageInfo_InodeExtendAttrsInfoPb.Merge(m, src)
}
func (m *InodeExtendAttrsInfoPb) XXX_Size() int {
        return m.Size()
}
func (m *InodeExtendAttrsInfoPb) XXX_DiscardUnknown() {
        xxx_messageInfo_InodeExtendAttrsInfoPb.DiscardUnknown(m)
}

var xxx_messageInfo_InodeExtendAttrsInfoPb proto.InternalMessageInfo

func (m *InodeExtendAttrsInfoPb) GetInodeID() uint64 {
        if m != nil {
                return m.InodeID
        }
        return 0
}

func (m *InodeExtendAttrsInfoPb) GetExtendAttrs() []*ExtendAttrInfoPb {
        if m != nil {
                return m.ExtendAttrs
        }
        return nil
}

type BatchInodeGetRequest struct {
        VolName        string   `protobuf:"bytes,1,opt,name=VolName,proto3" json:"vol"`
        PartitionID    uint64   `protobuf:"varint,2,opt,name=PartitionID,proto3" json:"pid"`
        Inodes         []uint64 `protobuf:"varint,3,rep,packed,name=Inodes,proto3" json:"inos"`
        WithExtendAttr bool     `protobuf:"varint,4,opt,name=WithExtendAttr,proto3" json:"withXAttr"`
        ExtendAttrKeys []string `protobuf:"bytes,5,rep,name=ExtendAttrKeys,proto3" json:"keys"`
}

func (m *BatchInodeGetRequest) Reset()         { *m = BatchInodeGetRequest{} }
func (m *BatchInodeGetRequest) String() string { return proto.CompactTextString(m) }
func (*BatchInodeGetRequest) ProtoMessage()    {}
func (*BatchInodeGetRequest) Descriptor() ([]byte, []int) {
        return fileDescriptor_e604833c2b457e38, []int{6}
}
func (m *BatchInodeGetRequest) XXX_Unmarshal(b []byte) error {
        return m.Unmarshal(b)
}
func (m *BatchInodeGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
        if deterministic {
                return xxx_messageInfo_BatchInodeGetRequest.Marshal(b, m, deterministic)
        } else {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil {
                        return nil, err
                }
                return b[:n], nil
        }
}
func (m *BatchInodeGetRequest) XXX_Merge(src proto.Message) {
        xxx_messageInfo_BatchInodeGetRequest.Merge(m, src)
}
func (m *BatchInodeGetRequest) XXX_Size() int {
        return m.Size()
}
func (m *BatchInodeGetRequest) XXX_DiscardUnknown() {
        xxx_messageInfo_BatchInodeGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchInodeGetRequest proto.InternalMessageInfo

func (m *BatchInodeGetRequest) GetVolName() string {
        if m != nil {
                return m.VolName
        }
        return ""
}

func (m *BatchInodeGetRequest) GetPartitionID() uint64 {
        if m != nil {
                return m.PartitionID
        }
        return 0
}

func (m *BatchInodeGetRequest) GetInodes() []uint64 {
        if m != nil {
                return m.Inodes
        }
        return nil
}

func (m *BatchInodeGetRequest) GetWithExtendAttr() bool {
        if m != nil {
                return m.WithExtendAttr
        }
        return false
}

func (m *BatchInodeGetRequest) GetExtendAttrKeys() []string {
        if m != nil {
                return m.ExtendAttrKeys
        }
        return nil
}

type BatchInodeGetResponsePb struct {
        Infos       []*InodeInfoPb            `protobuf:"bytes,1,rep,name=Infos,proto3" json:"Infos,omitempty"`
        ExtendAttrs []*InodeExtendAttrsInfoPb `protobuf:"bytes,2,rep,name=ExtendAttrs,proto3" json:"ExtendAttrs,omitempty"`
}

func (m *BatchInodeGetResponsePb) Reset()         { *m = BatchInodeGetResponsePb{} }
func (m *BatchInodeGetResponsePb) String() string { return proto.CompactTextString(m) }
func (*BatchInodeGetResponsePb) ProtoMessage()    {}
func (*BatchInodeGetResponsePb) Descriptor() ([]byte, []int) {
        return fileDescriptor_e604833c2b457e38, []int{7}
}
func (m *BatchInodeGetResponsePb) XXX_Unmarshal(b []byte) error {
        return m.Unmarshal(b)
}
func (m *BatchInodeGetResponsePb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
        if deterministic {
                return xxx_messageInfo_BatchInodeGetResponsePb.Marshal(b, m, deterministic)
        } else {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil {
                        return nil, err
                }
                return b[:n], nil
        }
}
func (m *BatchInodeGetResponsePb) XXX_Merge(src proto.Message) {
        xxx_messageInfo_BatchInodeGetResponsePb.Merge(m, src)
}
func (m *BatchInodeGetResponsePb) XXX_Size() int {
        return m.Size()
}
func (m *BatchInodeGetResponsePb) XXX_DiscardUnknown() {
        xxx_messageInfo_BatchInodeGetResponsePb.DiscardUnknown(m)
}

var xxx_messageInfo_BatchInodeGetResponsePb proto.InternalMessageInfo

func (m *BatchInodeGetResponsePb) GetInfos() []*InodeInfoPb {
        if m != nil {
                return m.Infos
        }
        return nil
}

func (m *BatchInodeGetResponsePb) GetExtendAttrs() []*InodeExtendAttrsInfoPb {
        if m != nil {
                return m.ExtendAttrs
        }
        return nil
}

func init() {
        proto.RegisterType((*Dentry)(nil), "proto.Dentry")
        proto.RegisterType((*ReadDirRequest)(nil), "proto.ReadDirRequest")
        proto.RegisterType((*ReadDirResponse)(nil), "proto.ReadDirResponse")
        proto.RegisterType((*InodeInfoPb)(nil), "proto.InodeInfoPb")
        proto.RegisterType((*ExtendAttrInfoPb)(nil), "proto.ExtendAttrInfoPb")
        proto.RegisterType((*InodeExtendAttrsInfoPb)(nil), "proto.InodeExtendAttrsInfoPb")
        proto.RegisterType((*BatchInodeGetRequest)(nil), "proto.BatchInodeGetRequest")
        proto.RegisterType((*BatchInodeGetResponsePb)(nil), "proto.BatchInodeGetResponsePb")
}

func init() { proto.RegisterFile("fs.proto", fileDescriptor_e604833c2b457e38) }

var fileDescriptor_e604833c2b457e38 = []byte{
        // 819 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x54, 0x41, 0x6f, 0xe3, 0x44,
        0x14, 0xce, 0xd4, 0x89, 0xe3, 0xbc, 0x34, 0xdd, 0x6a, 0x84, 0x58, 0xb3, 0x62, 0x3b, 0xde, 0x82,
        0xc0, 0x1c, 0x68, 0x11, 0x08, 0x09, 0xc1, 0x01, 0xad, 0x1b, 0xa8, 0x02, 0x6a, 0x15, 0xcd, 0x96,
        0x85, 0x5b, 0xe5, 0xc4, 0x93, 0x64, 0xd4, 0x64, 0x26, 0xd8, 0x93, 0xa5, 0xd9, 0xff, 0x80, 0x84,
        0x90, 0x40, 0x7b, 0x65, 0xff, 0x0a, 0x97, 0x3d, 0xee, 0x99, 0x83, 0x85, 0xca, 0xcd, 0xff, 0x01,
        0x09, 0xcd, 0xd8, 0x89, 0x2d, 0xb3, 0xf4, 0xc6, 0x29, 0xf1, 0xf7, 0xde, 0x37, 0xef, 0x7b, 0xf3,
        0xbd, 0x37, 0xe0, 0x4c, 0x92, 0xa3, 0x65, 0x2c, 0x95, 0xc4, 0x2d, 0xf3, 0x73, 0xef, 0xfd, 0x29,
        0x57, 0xb3, 0xd5, 0xe8, 0x68, 0x2c, 0x17, 0xc7, 0x53, 0x39, 0x95, 0xc7, 0x06, 0x1e, 0xad, 0x26,
        0xe6, 0xcb, 0x7c, 0x98, 0x7f, 0x39, 0xeb, 0xf0, 0x57, 0x04, 0x76, 0x9f, 0x09, 0x15, 0xaf, 0xf1,
        0x5b, 0xe0, 0x0c, 0xc3, 0x98, 0x09, 0x35, 0x88, 0x5c, 0xe4, 0x21, 0xbf, 0x19, 0xb4, 0xb3, 0x94,
        0x58, 0x4b, 0x1e, 0xd1, 0x6d, 0x00, 0xbf, 0x09, 0xcd, 0xf3, 0x70, 0xc1, 0xdc, 0x1d, 0x0f, 0xf9,
        0x9d, 0xc0, 0xc9, 0x52, 0xd2, 0x14, 0xe1, 0x82, 0x51, 0x83, 0xe2, 0xfb, 0xd0, 0x1a, 0x08, 0x19,
        0x31, 0xd7, 0x2a, 0xf9, 0x5c, 0x48, 0x9a, 0xa3, 0x9a, 0x7c, 0xb1, 0x5e, 0x32, 0xb7, 0xe9, 0x21,
        0xbf, 0x97, 0x93, 0xd5, 0x7a, 0xc9, 0xa8, 0x41, 0x3f, 0xdd, 0x7d, 0xf9, 0x1b, 0x69, 0xfc, 0xf4,
        0x9c, 0x34, 0x9e, 0x3d, 0x27, 0x8d, 0xc3, 0x14, 0xc1, 0x1e, 0x65, 0x61, 0xd4, 0xe7, 0x31, 0x65,
        0xdf, 0xaf, 0x58, 0xa2, 0xf0, 0x03, 0x68, 0x3f, 0x96, 0x73, 0x53, 0x1e, 0x99, 0xf2, 0xe6, 0xfc,
        0x27, 0x72, 0x4e, 0x37, 0x38, 0x7e, 0x0f, 0xba, 0xc3, 0x30, 0x56, 0x5c, 0x71, 0x29, 0x06, 0x7d,
        0xa3, 0xb2, 0xd2, 0x46, 0x35, 0x86, 0xdf, 0xde, 0xb6, 0xdb, 0x2f, 0xe4, 0x1a, 0x41, 0x4b, 0xad,
        0x77, 0x1b, 0xc1, 0x87, 0x60, 0x9f, 0x85, 0xf1, 0x15, 0x8b, 0x8d, 0xe8, 0x4e, 0x00, 0x59, 0x4a,
        0xec, 0x85, 0x41, 0x68, 0x11, 0xc1, 0xef, 0x40, 0x7b, 0x90, 0x04, 0xa1, 0x1a, 0xcf, 0xdc, 0x96,
        0x87, 0x7c, 0x27, 0xd8, 0xcd, 0x52, 0xe2, 0xf0, 0xe4, 0x72, 0xa4, 0x31, 0xba, 0x09, 0xd6, 0x1a,
        0xfc, 0x11, 0xc1, 0x9d, 0x6d, 0x83, 0xc9, 0x52, 0x8a, 0x84, 0xe1, 0xcf, 0xc0, 0x39, 0x99, 0xf1,
        0x79, 0x14, 0x33, 0xe1, 0x22, 0xcf, 0xf2, 0xbb, 0x1f, 0xf6, 0x72, 0x9f, 0x8e, 0x72, 0x8f, 0x82,
        0xfd, 0x17, 0x29, 0x69, 0xe8, 0xd3, 0xc7, 0x45, 0x1a, 0xdd, 0x12, 0xf0, 0x31, 0xc0, 0x39, 0xbb,
        0x56, 0x85, 0xdc, 0xdc, 0xa0, 0x3b, 0x59, 0x4a, 0xba, 0x82, 0x5d, 0xab, 0xcb, 0x42, 0x73, 0x25,
        0xa5, 0xa6, 0xe7, 0x77, 0x0b, 0xba, 0xc6, 0xa6, 0x81, 0x98, 0xc8, 0xe1, 0xa8, 0xf4, 0x12, 0xfd,
        0x97, 0x97, 0x67, 0x3a, 0xba, 0x53, 0x7a, 0xb9, 0x90, 0x11, 0xa3, 0x06, 0xc5, 0x04, 0x5a, 0xe7,
        0x73, 0x2e, 0xae, 0xcc, 0xcd, 0xf6, 0x82, 0x4e, 0x96, 0x92, 0x96, 0xd0, 0x00, 0xcd, 0x71, 0x7c,
        0x0f, 0x9a, 0x8f, 0xf8, 0xd3, 0x7c, 0x14, 0x9a, 0x81, 0x9d, 0xa5, 0x64, 0x27, 0x79, 0x4a, 0x0d,
        0x86, 0xdf, 0x00, 0xeb, 0x1b, 0x1e, 0x99, 0xbb, 0xec, 0xe5, 0x75, 0x57, 0x3c, 0xa2, 0x1a, 0xd3,
        0xa1, 0x53, 0x1e, 0xb9, 0x76, 0x19, 0x9a, 0xea, 0xd0, 0x29, 0x8f, 0xf0, 0xbb, 0x00, 0xa7, 0x4c,
        0xb0, 0x38, 0xd4, 0xfe, 0xba, 0xed, 0x52, 0xf4, 0x94, 0x09, 0x5a, 0x09, 0xe1, 0x4f, 0x00, 0xce,
        0x64, 0xc4, 0x27, 0xeb, 0x0b, 0xbe, 0x60, 0xae, 0xe3, 0x21, 0xdf, 0x0a, 0x5c, 0x7d, 0xaf, 0x7f,
        0xa4, 0x04, 0x4e, 0x56, 0x23, 0xf6, 0xe5, 0x23, 0x1d, 0xd1, 0x92, 0x16, 0x8a, 0x56, 0x72, 0x35,
        0xf3, 0x24, 0x66, 0xa1, 0x62, 0x86, 0xd9, 0xb9, 0x8d, 0x39, 0x56, 0xb4, 0x92, 0xab, 0x99, 0x0f,
        0xc7, 0x63, 0x96, 0x24, 0x86, 0x09, 0xb7, 0x31, 0x43, 0x45, 0x2b, 0xb9, 0x98, 0x80, 0x7d, 0x11,
        0xc6, 0x53, 0xa6, 0xdc, 0xae, 0x87, 0xfc, 0xdd, 0xbc, 0x25, 0x35, 0x55, 0xb4, 0x80, 0x6b, 0x2e,
        0x5e, 0xc2, 0xfe, 0x17, 0xd7, 0x8a, 0x89, 0xe8, 0xa1, 0x52, 0x71, 0xe1, 0xe4, 0x66, 0x67, 0xd1,
        0x2b, 0x77, 0x96, 0x40, 0xeb, 0x71, 0x38, 0x5f, 0x6d, 0x56, 0xda, 0x58, 0xf5, 0x44, 0x03, 0x34,
        0xc7, 0x6b, 0x05, 0x7e, 0x41, 0xf0, 0xba, 0x99, 0x80, 0xb2, 0x4c, 0x52, 0xd4, 0x79, 0x00, 0xed,
        0x7c, 0x80, 0xfa, 0xf5, 0x99, 0xd9, 0xe0, 0xf8, 0x2b, 0xe8, 0x56, 0x78, 0xee, 0x8e, 0x99, 0xf1,
        0xbb, 0xc5, 0x8c, 0xd7, 0x85, 0xe7, 0xd3, 0xcb, 0xca, 0x7c, 0x5a, 0x25, 0xd7, 0x74, 0xfd, 0x8d,
        0xe0, 0x35, 0xb3, 0x66, 0xa6, 0xd4, 0x29, 0x53, 0xff, 0xcf, 0xab, 0xe1, 0x81, 0x6d, 0x0a, 0x24,
        0xae, 0xe5, 0x59, 0x9b, 0x37, 0x83, 0x0b, 0x99, 0xd0, 0x02, 0xc7, 0x1f, 0xc3, 0xde, 0xb7, 0x5c,
        0xcd, 0x4a, 0xa5, 0x66, 0xc6, 0x9d, 0xa0, 0x97, 0xa5, 0xa4, 0xf3, 0x03, 0x57, 0xb3, 0xef, 0x34,
        0x48, 0x6b, 0x49, 0xf8, 0x03, 0xd8, 0x2b, 0xbf, 0xbe, 0x66, 0xeb, 0xc4, 0x6d, 0x79, 0xd6, 0xc6,
        0xae, 0x2b, 0xb6, 0x4e, 0x68, 0x2d, 0x5e, 0xeb, 0xff, 0x67, 0x04, 0x77, 0x6b, 0xfd, 0xe7, 0x8f,
        0xca, 0x70, 0x84, 0x7d, 0xbd, 0xca, 0x13, 0x99, 0x14, 0x6f, 0x0a, 0x2e, 0xee, 0xbb, 0xb2, 0xed,
        0x34, 0x4f, 0xc0, 0x9f, 0xbf, 0xca, 0x9f, 0xfb, 0xd5, 0xfc, 0x7f, 0xd9, 0x7e, 0x8b, 0x29, 0xc1,
        0xfe, 0x8b, 0x9b, 0x03, 0xf4, 0xf2, 0xe6, 0x00, 0xfd, 0x79, 0x73, 0x80, 0x9e, 0xfd, 0x75, 0xd0,
        0x18, 0xd9, 0xe6, 0xa8, 0x8f, 0xfe, 0x09, 0x00, 0x00, 0xff, 0xff, 0x3d, 0xc1, 0xf5, 0x09, 0xb8,
        0x06, 0x00, 0x00,
}

func (m *Dentry) Marshal() (dAtA []byte, err error) {
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil {
                return nil, err
        }
        return dAtA[:n], nil
}

func (m *Dentry) MarshalTo(dAtA []byte) (int, error) {
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dentry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Type != 0 {
                i = encodeVarintFs(dAtA, i, uint64(m.Type))
                i--
                dAtA[i] = 0x20
        }
        if m.Inode != 0 {
                i = encodeVarintFs(dAtA, i, uint64(m.Inode))
                i--
                dAtA[i] = 0x18
        }
        if len(m.Name) > 0 {
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintFs(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }
        if m.ParentId != 0 {
                i = encodeVarintFs(dAtA, i, uint64(m.ParentId))
                i--
                dAtA[i] = 0x8
        }
        return len(dAtA) - i, nil
}

func (m *ReadDirRequest) Marshal() (dAtA []byte, err error) {
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil {
                return nil, err
        }
        return dAtA[:n], nil
}

func (m *ReadDirRequest) MarshalTo(dAtA []byte) (int, error) {
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadDirRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.IsBatch {
                i--
                if m.IsBatch {
                        dAtA[i] = 1
                } else {
                        dAtA[i] = 0
                }
                i--
                dAtA[i] = 0x28
        }
        if len(m.Marker) > 0 {
                i -= len(m.Marker)
                copy(dAtA[i:], m.Marker)
                i = encodeVarintFs(dAtA, i, uint64(len(m.Marker)))
                i--
                dAtA[i] = 0x22
        }
        if m.ParentID != 0 {
                i = encodeVarintFs(dAtA, i, uint64(m.ParentID))
                i--
                dAtA[i] = 0x18
        }
        if m.PartitionID != 0 {
                i = encodeVarintFs(dAtA, i, uint64(m.PartitionID))
                i--
                dAtA[i] = 0x10
        }
        if len(m.VolName) > 0 {
                i -= len(m.VolName)
                copy(dAtA[i:], m.VolName)
                i = encodeVarintFs(dAtA, i, uint64(len(m.VolName)))
                i--
                dAtA[i] = 0xa
        }
        return len(dAtA) - i, nil
}

func (m *ReadDirResponse) Marshal() (dAtA []byte, err error) {
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil {
                return nil, err
        }
        return dAtA[:n], nil
}

func (m *ReadDirResponse) MarshalTo(dAtA []byte) (int, error) {
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadDirResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.NextMarker) > 0 {
                i -= len(m.NextMarker)
                copy(dAtA[i:], m.NextMarker)
                i = encodeVarintFs(dAtA, i, uint64(len(m.NextMarker)))
                i--
                dAtA[i] = 0x12
        }
        if len(m.Children) > 0 {
                for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
                        {
                                size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil {
                                        return 0, err
                                }
                                i -= size
                                i = encodeVarintFs(dAtA, i, uint64(size))
                        }
                        i--
                        dAtA[i] = 0xa
                }
        }
        return len(dAtA) - i, nil
}

func (m *InodeInfoPb) Marshal() (dAtA []byte, err error) {
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil {
                return nil, err
        }
        return dAtA[:n], nil
}

func (m *InodeInfoPb) MarshalTo(dAtA []byte) (int, error) {
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InodeInfoPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Target) > 0 {
                i -= len(m.Target)
                copy(dAtA[i:], m.Target)
                i = encodeVarintFs(dAtA, i, uint64(len(m.Target)))
                i--
                dAtA[i] = 0x5a
        }
        if m.AccessTime != 0 {
                i = encodeVarintFs(dAtA, i, uint64(m.AccessTime))
                i--
                dAtA[i] = 0x50
        }
        if m.CreateTime != 0 {
                i = encodeVarintFs(dAtA, i, uint64(m.CreateTime))
                i--
                dAtA[i] = 0x48
        }
        if m.ModifyTime != 0 {
                i = encodeVarintFs(dAtA, i, uint64(m.ModifyTime))
                i--
                dAtA[i] = 0x40
        }
        if m.Generation != 0 {
                i = encodeVarintFs(dAtA, i, uint64(m.Generation))
                i--
                dAtA[i] = 0x38
        }
        if m.Gid != 0 {
                i = encodeVarintFs(dAtA, i, uint64(m.Gid))
                i--
                dAtA[i] = 0x30
        }
        if m.Uid != 0 {
                i = encodeVarintFs(dAtA, i, uint64(m.Uid))
                i--
                dAtA[i] = 0x28
        }
        if m.Size_ != 0 {
                i = encodeVarintFs(dAtA, i, uint64(m.Size_))
                i--
                dAtA[i] = 0x20
        }
        if m.Nlink != 0 {
                i = encodeVarintFs(dAtA, i, uint64(m.Nlink))
                i--
                dAtA[i] = 0x18
        }
        if m.Mode != 0 {
                i = encodeVarintFs(dAtA, i, uint64(m.Mode))
                i--
                dAtA[i] = 0x10
        }
        if m.Inode != 0 {
                i = encodeVarintFs(dAtA, i, uint64(m.Inode))
                i--
                dAtA[i] = 0x8
        }
        return len(dAtA) - i, nil
}

func (m *ExtendAttrInfoPb) Marshal() (dAtA []byte, err error) {
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil {
                return nil, err
        }
        return dAtA[:n], nil
}

func (m *ExtendAttrInfoPb) MarshalTo(dAtA []byte) (int, error) {
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtendAttrInfoPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Value) > 0 {
                i -= len(m.Value)
                copy(dAtA[i:], m.Value)
                i = encodeVarintFs(dAtA, i, uint64(len(m.Value)))
                i--
                dAtA[i] = 0x12
        }
        if len(m.Name) > 0 {
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintFs(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0xa
        }
        return len(dAtA) - i, nil
}

func (m *InodeExtendAttrsInfoPb) Marshal() (dAtA []byte, err error) {
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil {
                return nil, err
        }
        return dAtA[:n], nil
}

func (m *InodeExtendAttrsInfoPb) MarshalTo(dAtA []byte) (int, error) {
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InodeExtendAttrsInfoPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ExtendAttrs) > 0 {
                for iNdEx := len(m.ExtendAttrs) - 1; iNdEx >= 0; iNdEx-- {
                        {
                                size, err := m.ExtendAttrs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil {
                                        return 0, err
                                }
                                i -= size
                                i = encodeVarintFs(dAtA, i, uint64(size))
                        }
                        i--
                        dAtA[i] = 0x12
                }
        }
        if m.InodeID != 0 {
                i = encodeVarintFs(dAtA, i, uint64(m.InodeID))
                i--
                dAtA[i] = 0x8
        }
        return len(dAtA) - i, nil
}

func (m *BatchInodeGetRequest) Marshal() (dAtA []byte, err error) {
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil {
                return nil, err
        }
        return dAtA[:n], nil
}

func (m *BatchInodeGetRequest) MarshalTo(dAtA []byte) (int, error) {
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchInodeGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ExtendAttrKeys) > 0 {
                for iNdEx := len(m.ExtendAttrKeys) - 1; iNdEx >= 0; iNdEx-- {
                        i -= len(m.ExtendAttrKeys[iNdEx])
                        copy(dAtA[i:], m.ExtendAttrKeys[iNdEx])
                        i = encodeVarintFs(dAtA, i, uint64(len(m.ExtendAttrKeys[iNdEx])))
                        i--
                        dAtA[i] = 0x2a
                }
        }
        if m.WithExtendAttr {
                i--
                if m.WithExtendAttr {
                        dAtA[i] = 1
                } else {
                        dAtA[i] = 0
                }
                i--
                dAtA[i] = 0x20
        }
        if len(m.Inodes) > 0 {
                dAtA2 := make([]byte, len(m.Inodes)*10)
                var j1 int
                for _, num := range m.Inodes {
                        for num >= 1<<7 {
                                dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
                                num >>= 7
                                j1++
                        }
                        dAtA2[j1] = uint8(num)
                        j1++
                }
                i -= j1
                copy(dAtA[i:], dAtA2[:j1])
                i = encodeVarintFs(dAtA, i, uint64(j1))
                i--
                dAtA[i] = 0x1a
        }
        if m.PartitionID != 0 {
                i = encodeVarintFs(dAtA, i, uint64(m.PartitionID))
                i--
                dAtA[i] = 0x10
        }
        if len(m.VolName) > 0 {
                i -= len(m.VolName)
                copy(dAtA[i:], m.VolName)
                i = encodeVarintFs(dAtA, i, uint64(len(m.VolName)))
                i--
                dAtA[i] = 0xa
        }
        return len(dAtA) - i, nil
}

func (m *BatchInodeGetResponsePb) Marshal() (dAtA []byte, err error) {
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil {
                return nil, err
        }
        return dAtA[:n], nil
}

func (m *BatchInodeGetResponsePb) MarshalTo(dAtA []byte) (int, error) {
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchInodeGetResponsePb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.ExtendAttrs) > 0 {
                for iNdEx := len(m.ExtendAttrs) - 1; iNdEx >= 0; iNdEx-- {
                        {
                                size, err := m.ExtendAttrs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil {
                                        return 0, err
                                }
                                i -= size
                                i = encodeVarintFs(dAtA, i, uint64(size))
                        }
                        i--
                        dAtA[i] = 0x12
                }
        }
        if len(m.Infos) > 0 {
                for iNdEx := len(m.Infos) - 1; iNdEx >= 0; iNdEx-- {
                        {
                                size, err := m.Infos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil {
                                        return 0, err
                                }
                                i -= size
                                i = encodeVarintFs(dAtA, i, uint64(size))
                        }
                        i--
                        dAtA[i] = 0xa
                }
        }
        return len(dAtA) - i, nil
}

func encodeVarintFs(dAtA []byte, offset int, v uint64) int {
        offset -= sovFs(v)
        base := offset
        for v >= 1<<7 {
                dAtA[offset] = uint8(v&0x7f | 0x80)
                v >>= 7
                offset++
        }
        dAtA[offset] = uint8(v)
        return base
}
func (m *Dentry) Size() (n int) {
        if m == nil {
                return 0
        }
        var l int
        _ = l
        if m.ParentId != 0 {
                n += 1 + sovFs(uint64(m.ParentId))
        }
        l = len(m.Name)
        if l > 0 {
                n += 1 + l + sovFs(uint64(l))
        }
        if m.Inode != 0 {
                n += 1 + sovFs(uint64(m.Inode))
        }
        if m.Type != 0 {
                n += 1 + sovFs(uint64(m.Type))
        }
        return n
}

func (m *ReadDirRequest) Size() (n int) {
        if m == nil {
                return 0
        }
        var l int
        _ = l
        l = len(m.VolName)
        if l > 0 {
                n += 1 + l + sovFs(uint64(l))
        }
        if m.PartitionID != 0 {
                n += 1 + sovFs(uint64(m.PartitionID))
        }
        if m.ParentID != 0 {
                n += 1 + sovFs(uint64(m.ParentID))
        }
        l = len(m.Marker)
        if l > 0 {
                n += 1 + l + sovFs(uint64(l))
        }
        if m.IsBatch {
                n += 2
        }
        return n
}

func (m *ReadDirResponse) Size() (n int) {
        if m == nil {
                return 0
        }
        var l int
        _ = l
        if len(m.Children) > 0 {
                for _, e := range m.Children {
                        l = e.Size()
                        n += 1 + l + sovFs(uint64(l))
                }
        }
        l = len(m.NextMarker)
        if l > 0 {
                n += 1 + l + sovFs(uint64(l))
        }
        return n
}

func (m *InodeInfoPb) Size() (n int) {
        if m == nil {
                return 0
        }
        var l int
        _ = l
        if m.Inode != 0 {
                n += 1 + sovFs(uint64(m.Inode))
        }
        if m.Mode != 0 {
                n += 1 + sovFs(uint64(m.Mode))
        }
        if m.Nlink != 0 {
                n += 1 + sovFs(uint64(m.Nlink))
        }
        if m.Size_ != 0 {
                n += 1 + sovFs(uint64(m.Size_))
        }
        if m.Uid != 0 {
                n += 1 + sovFs(uint64(m.Uid))
        }
        if m.Gid != 0 {
                n += 1 + sovFs(uint64(m.Gid))
        }
        if m.Generation != 0 {
                n += 1 + sovFs(uint64(m.Generation))
        }
        if m.ModifyTime != 0 {
                n += 1 + sovFs(uint64(m.ModifyTime))
        }
        if m.CreateTime != 0 {
                n += 1 + sovFs(uint64(m.CreateTime))
        }
        if m.AccessTime != 0 {
                n += 1 + sovFs(uint64(m.AccessTime))
        }
        l = len(m.Target)
        if l > 0 {
                n += 1 + l + sovFs(uint64(l))
        }
        return n
}

func (m *ExtendAttrInfoPb) Size() (n int) {
        if m == nil {
                return 0
        }
        var l int
        _ = l
        l = len(m.Name)
        if l > 0 {
                n += 1 + l + sovFs(uint64(l))
        }
        l = len(m.Value)
        if l > 0 {
                n += 1 + l + sovFs(uint64(l))
        }
        return n
}

func (m *InodeExtendAttrsInfoPb) Size() (n int) {
        if m == nil {
                return 0
        }
        var l int
        _ = l
        if m.InodeID != 0 {
                n += 1 + sovFs(uint64(m.InodeID))
        }
        if len(m.ExtendAttrs) > 0 {
                for _, e := range m.ExtendAttrs {
                        l = e.Size()
                        n += 1 + l + sovFs(uint64(l))
                }
        }
        return n
}

func (m *BatchInodeGetRequest) Size() (n int) {
        if m == nil {
                return 0
        }
        var l int
        _ = l
        l = len(m.VolName)
        if l > 0 {
                n += 1 + l + sovFs(uint64(l))
        }
        if m.PartitionID != 0 {
                n += 1 + sovFs(uint64(m.PartitionID))
        }
        if len(m.Inodes) > 0 {
                l = 0
                for _, e := range m.Inodes {
                        l += sovFs(uint64(e))
                }
                n += 1 + sovFs(uint64(l)) + l
        }
        if m.WithExtendAttr {
                n += 2
        }
        if len(m.ExtendAttrKeys) > 0 {
                for _, s := range m.ExtendAttrKeys {
                        l = len(s)
                        n += 1 + l + sovFs(uint64(l))
                }
        }
        return n
}

func (m *BatchInodeGetResponsePb) Size() (n int) {
        if m == nil {
                return 0
        }
        var l int
        _ = l
        if len(m.Infos) > 0 {
                for _, e := range m.Infos {
                        l = e.Size()
                        n += 1 + l + sovFs(uint64(l))
                }
        }
        if len(m.ExtendAttrs) > 0 {
                for _, e := range m.ExtendAttrs {
                        l = e.Size()
                        n += 1 + l + sovFs(uint64(l))
                }
        }
        return n
}

func sovFs(x uint64) (n int) {
        return (math_bits.Len64(x|1) + 6) / 7
}
func sozFs(x uint64) (n int) {
        return sovFs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Dentry) Unmarshal(dAtA []byte) error {
        l := len(dAtA)
        iNdEx := 0
        for iNdEx < l {
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 {
                        if shift >= 64 {
                                return ErrIntOverflowFs
                        }
                        if iNdEx >= l {
                                return io.ErrUnexpectedEOF
                        }
                        b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&0x7F) << shift
                        if b < 0x80 {
                                break
                        }
                }
                fieldNum := int32(wire >> 3)
                wireType := int(wire & 0x7)
                if wireType == 4 {
                        return fmt.Errorf("proto: Dentry: wiretype end group for non-group")
                }
                if fieldNum <= 0 {
                        return fmt.Errorf("proto: Dentry: illegal tag %d (wire type %d)", fieldNum, wire)
                }
                switch fieldNum {
                case 1:
                        if wireType != 0 {
                                return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
                        }
                        m.ParentId = 0
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                m.ParentId |= uint64(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                case 2:
                        if wireType != 2 {
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }
                        var stringLen uint64
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                        intStringLen := int(stringLen)
                        if intStringLen < 0 {
                                return ErrInvalidLengthFs
                        }
                        postIndex := iNdEx + intStringLen
                        if postIndex < 0 {
                                return ErrInvalidLengthFs
                        }
                        if postIndex > l {
                                return io.ErrUnexpectedEOF
                        }
                        m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex
                case 3:
                        if wireType != 0 {
                                return fmt.Errorf("proto: wrong wireType = %d for field Inode", wireType)
                        }
                        m.Inode = 0
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                m.Inode |= uint64(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                case 4:
                        if wireType != 0 {
                                return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
                        }
                        m.Type = 0
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                m.Type |= uint32(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                default:
                        iNdEx = preIndex
                        skippy, err := skipFs(dAtA[iNdEx:])
                        if err != nil {
                                return err
                        }
                        if (skippy < 0) || (iNdEx+skippy) < 0 {
                                return ErrInvalidLengthFs
                        }
                        if (iNdEx + skippy) > l {
                                return io.ErrUnexpectedEOF
                        }
                        iNdEx += skippy
                }
        }

        if iNdEx > l {
                return io.ErrUnexpectedEOF
        }
        return nil
}
func (m *ReadDirRequest) Unmarshal(dAtA []byte) error {
        l := len(dAtA)
        iNdEx := 0
        for iNdEx < l {
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 {
                        if shift >= 64 {
                                return ErrIntOverflowFs
                        }
                        if iNdEx >= l {
                                return io.ErrUnexpectedEOF
                        }
                        b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&0x7F) << shift
                        if b < 0x80 {
                                break
                        }
                }
                fieldNum := int32(wire >> 3)
                wireType := int(wire & 0x7)
                if wireType == 4 {
                        return fmt.Errorf("proto: ReadDirRequest: wiretype end group for non-group")
                }
                if fieldNum <= 0 {
                        return fmt.Errorf("proto: ReadDirRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }
                switch fieldNum {
                case 1:
                        if wireType != 2 {
                                return fmt.Errorf("proto: wrong wireType = %d for field VolName", wireType)
                        }
                        var stringLen uint64
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                        intStringLen := int(stringLen)
                        if intStringLen < 0 {
                                return ErrInvalidLengthFs
                        }
                        postIndex := iNdEx + intStringLen
                        if postIndex < 0 {
                                return ErrInvalidLengthFs
                        }
                        if postIndex > l {
                                return io.ErrUnexpectedEOF
                        }
                        m.VolName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex
                case 2:
                        if wireType != 0 {
                                return fmt.Errorf("proto: wrong wireType = %d for field PartitionID", wireType)
                        }
                        m.PartitionID = 0
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                m.PartitionID |= uint64(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                case 3:
                        if wireType != 0 {
                                return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
                        }
                        m.ParentID = 0
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                m.ParentID |= uint64(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                case 4:
                        if wireType != 2 {
                                return fmt.Errorf("proto: wrong wireType = %d for field Marker", wireType)
                        }
                        var stringLen uint64
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                        intStringLen := int(stringLen)
                        if intStringLen < 0 {
                                return ErrInvalidLengthFs
                        }
                        postIndex := iNdEx + intStringLen
                        if postIndex < 0 {
                                return ErrInvalidLengthFs
                        }
                        if postIndex > l {
                                return io.ErrUnexpectedEOF
                        }
                        m.Marker = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex
                case 5:
                        if wireType != 0 {
                                return fmt.Errorf("proto: wrong wireType = %d for field IsBatch", wireType)
                        }
                        var v int
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                v |= int(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                        m.IsBatch = bool(v != 0)
                default:
                        iNdEx = preIndex
                        skippy, err := skipFs(dAtA[iNdEx:])
                        if err != nil {
                                return err
                        }
                        if (skippy < 0) || (iNdEx+skippy) < 0 {
                                return ErrInvalidLengthFs
                        }
                        if (iNdEx + skippy) > l {
                                return io.ErrUnexpectedEOF
                        }
                        iNdEx += skippy
                }
        }

        if iNdEx > l {
                return io.ErrUnexpectedEOF
        }
        return nil
}
func (m *ReadDirResponse) Unmarshal(dAtA []byte) error {
        l := len(dAtA)
        iNdEx := 0
        for iNdEx < l {
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 {
                        if shift >= 64 {
                                return ErrIntOverflowFs
                        }
                        if iNdEx >= l {
                                return io.ErrUnexpectedEOF
                        }
                        b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&0x7F) << shift
                        if b < 0x80 {
                                break
                        }
                }
                fieldNum := int32(wire >> 3)
                wireType := int(wire & 0x7)
                if wireType == 4 {
                        return fmt.Errorf("proto: ReadDirResponse: wiretype end group for non-group")
                }
                if fieldNum <= 0 {
                        return fmt.Errorf("proto: ReadDirResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }
                switch fieldNum {
                case 1:
                        if wireType != 2 {
                                return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
                        }
                        var msglen int
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                        if msglen < 0 {
                                return ErrInvalidLengthFs
                        }
                        postIndex := iNdEx + msglen
                        if postIndex < 0 {
                                return ErrInvalidLengthFs
                        }
                        if postIndex > l {
                                return io.ErrUnexpectedEOF
                        }
                        m.Children = append(m.Children, Dentry{})
                        if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
                                return err
                        }
                        iNdEx = postIndex
                case 2:
                        if wireType != 2 {
                                return fmt.Errorf("proto: wrong wireType = %d for field NextMarker", wireType)
                        }
                        var stringLen uint64
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                        intStringLen := int(stringLen)
                        if intStringLen < 0 {
                                return ErrInvalidLengthFs
                        }
                        postIndex := iNdEx + intStringLen
                        if postIndex < 0 {
                                return ErrInvalidLengthFs
                        }
                        if postIndex > l {
                                return io.ErrUnexpectedEOF
                        }
                        m.NextMarker = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex
                default:
                        iNdEx = preIndex
                        skippy, err := skipFs(dAtA[iNdEx:])
                        if err != nil {
                                return err
                        }
                        if (skippy < 0) || (iNdEx+skippy) < 0 {
                                return ErrInvalidLengthFs
                        }
                        if (iNdEx + skippy) > l {
                                return io.ErrUnexpectedEOF
                        }
                        iNdEx += skippy
                }
        }

        if iNdEx > l {
                return io.ErrUnexpectedEOF
        }
        return nil
}
func (m *InodeInfoPb) Unmarshal(dAtA []byte) error {
        l := len(dAtA)
        iNdEx := 0
        for iNdEx < l {
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 {
                        if shift >= 64 {
                                return ErrIntOverflowFs
                        }
                        if iNdEx >= l {
                                return io.ErrUnexpectedEOF
                        }
                        b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&0x7F) << shift
                        if b < 0x80 {
                                break
                        }
                }
                fieldNum := int32(wire >> 3)
                wireType := int(wire & 0x7)
                if wireType == 4 {
                        return fmt.Errorf("proto: InodeInfoPb: wiretype end group for non-group")
                }
                if fieldNum <= 0 {
                        return fmt.Errorf("proto: InodeInfoPb: illegal tag %d (wire type %d)", fieldNum, wire)
                }
                switch fieldNum {
                case 1:
                        if wireType != 0 {
                                return fmt.Errorf("proto: wrong wireType = %d for field Inode", wireType)
                        }
                        m.Inode = 0
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                m.Inode |= uint64(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                case 2:
                        if wireType != 0 {
                                return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
                        }
                        m.Mode = 0
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                m.Mode |= uint32(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                case 3:
                        if wireType != 0 {
                                return fmt.Errorf("proto: wrong wireType = %d for field Nlink", wireType)
                        }
                        m.Nlink = 0
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                m.Nlink |= uint32(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                case 4:
                        if wireType != 0 {
                                return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
                        }
                        m.Size_ = 0
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                m.Size_ |= uint64(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                case 5:
                        if wireType != 0 {
                                return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
                        }
                        m.Uid = 0
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                m.Uid |= uint32(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                case 6:
                        if wireType != 0 {
                                return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
                        }
                        m.Gid = 0
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                m.Gid |= uint32(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                case 7:
                        if wireType != 0 {
                                return fmt.Errorf("proto: wrong wireType = %d for field Generation", wireType)
                        }
                        m.Generation = 0
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                m.Generation |= uint64(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                case 8:
                        if wireType != 0 {
                                return fmt.Errorf("proto: wrong wireType = %d for field ModifyTime", wireType)
                        }
                        m.ModifyTime = 0
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                m.ModifyTime |= CubeFSTime(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                case 9:
                        if wireType != 0 {
                                return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
                        }
                        m.CreateTime = 0
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                m.CreateTime |= CubeFSTime(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                case 10:
                        if wireType != 0 {
                                return fmt.Errorf("proto: wrong wireType = %d for field AccessTime", wireType)
                        }
                        m.AccessTime = 0
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                m.AccessTime |= CubeFSTime(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                case 11:
                        if wireType != 2 {
                                return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
                        }
                        var byteLen int
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                byteLen |= int(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                        if byteLen < 0 {
                                return ErrInvalidLengthFs
                        }
                        postIndex := iNdEx + byteLen
                        if postIndex < 0 {
                                return ErrInvalidLengthFs
                        }
                        if postIndex > l {
                                return io.ErrUnexpectedEOF
                        }
                        m.Target = append(m.Target[:0], dAtA[iNdEx:postIndex]...)
                        if m.Target == nil {
                                m.Target = []byte{}
                        }
                        iNdEx = postIndex
                default:
                        iNdEx = preIndex
                        skippy, err := skipFs(dAtA[iNdEx:])
                        if err != nil {
                                return err
                        }
                        if (skippy < 0) || (iNdEx+skippy) < 0 {
                                return ErrInvalidLengthFs
                        }
                        if (iNdEx + skippy) > l {
                                return io.ErrUnexpectedEOF
                        }
                        iNdEx += skippy
                }
        }

        if iNdEx > l {
                return io.ErrUnexpectedEOF
        }
        return nil
}
func (m *ExtendAttrInfoPb) Unmarshal(dAtA []byte) error {
        l := len(dAtA)
        iNdEx := 0
        for iNdEx < l {
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 {
                        if shift >= 64 {
                                return ErrIntOverflowFs
                        }
                        if iNdEx >= l {
                                return io.ErrUnexpectedEOF
                        }
                        b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&0x7F) << shift
                        if b < 0x80 {
                                break
                        }
                }
                fieldNum := int32(wire >> 3)
                wireType := int(wire & 0x7)
                if wireType == 4 {
                        return fmt.Errorf("proto: ExtendAttrInfoPb: wiretype end group for non-group")
                }
                if fieldNum <= 0 {
                        return fmt.Errorf("proto: ExtendAttrInfoPb: illegal tag %d (wire type %d)", fieldNum, wire)
                }
                switch fieldNum {
                case 1:
                        if wireType != 2 {
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }
                        var stringLen uint64
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                        intStringLen := int(stringLen)
                        if intStringLen < 0 {
                                return ErrInvalidLengthFs
                        }
                        postIndex := iNdEx + intStringLen
                        if postIndex < 0 {
                                return ErrInvalidLengthFs
                        }
                        if postIndex > l {
                                return io.ErrUnexpectedEOF
                        }
                        m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex
                case 2:
                        if wireType != 2 {
                                return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
                        }
                        var stringLen uint64
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                        intStringLen := int(stringLen)
                        if intStringLen < 0 {
                                return ErrInvalidLengthFs
                        }
                        postIndex := iNdEx + intStringLen
                        if postIndex < 0 {
                                return ErrInvalidLengthFs
                        }
                        if postIndex > l {
                                return io.ErrUnexpectedEOF
                        }
                        m.Value = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex
                default:
                        iNdEx = preIndex
                        skippy, err := skipFs(dAtA[iNdEx:])
                        if err != nil {
                                return err
                        }
                        if (skippy < 0) || (iNdEx+skippy) < 0 {
                                return ErrInvalidLengthFs
                        }
                        if (iNdEx + skippy) > l {
                                return io.ErrUnexpectedEOF
                        }
                        iNdEx += skippy
                }
        }

        if iNdEx > l {
                return io.ErrUnexpectedEOF
        }
        return nil
}
func (m *InodeExtendAttrsInfoPb) Unmarshal(dAtA []byte) error {
        l := len(dAtA)
        iNdEx := 0
        for iNdEx < l {
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 {
                        if shift >= 64 {
                                return ErrIntOverflowFs
                        }
                        if iNdEx >= l {
                                return io.ErrUnexpectedEOF
                        }
                        b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&0x7F) << shift
                        if b < 0x80 {
                                break
                        }
                }
                fieldNum := int32(wire >> 3)
                wireType := int(wire & 0x7)
                if wireType == 4 {
                        return fmt.Errorf("proto: InodeExtendAttrsInfoPb: wiretype end group for non-group")
                }
                if fieldNum <= 0 {
                        return fmt.Errorf("proto: InodeExtendAttrsInfoPb: illegal tag %d (wire type %d)", fieldNum, wire)
                }
                switch fieldNum {
                case 1:
                        if wireType != 0 {
                                return fmt.Errorf("proto: wrong wireType = %d for field InodeID", wireType)
                        }
                        m.InodeID = 0
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                m.InodeID |= uint64(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                case 2:
                        if wireType != 2 {
                                return fmt.Errorf("proto: wrong wireType = %d for field ExtendAttrs", wireType)
                        }
                        var msglen int
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                        if msglen < 0 {
                                return ErrInvalidLengthFs
                        }
                        postIndex := iNdEx + msglen
                        if postIndex < 0 {
                                return ErrInvalidLengthFs
                        }
                        if postIndex > l {
                                return io.ErrUnexpectedEOF
                        }
                        m.ExtendAttrs = append(m.ExtendAttrs, &ExtendAttrInfoPb{})
                        if err := m.ExtendAttrs[len(m.ExtendAttrs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
                                return err
                        }
                        iNdEx = postIndex
                default:
                        iNdEx = preIndex
                        skippy, err := skipFs(dAtA[iNdEx:])
                        if err != nil {
                                return err
                        }
                        if (skippy < 0) || (iNdEx+skippy) < 0 {
                                return ErrInvalidLengthFs
                        }
                        if (iNdEx + skippy) > l {
                                return io.ErrUnexpectedEOF
                        }
                        iNdEx += skippy
                }
        }

        if iNdEx > l {
                return io.ErrUnexpectedEOF
        }
        return nil
}
func (m *BatchInodeGetRequest) Unmarshal(dAtA []byte) error {
        l := len(dAtA)
        iNdEx := 0
        for iNdEx < l {
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 {
                        if shift >= 64 {
                                return ErrIntOverflowFs
                        }
                        if iNdEx >= l {
                                return io.ErrUnexpectedEOF
                        }
                        b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&0x7F) << shift
                        if b < 0x80 {
                                break
                        }
                }
                fieldNum := int32(wire >> 3)
                wireType := int(wire & 0x7)
                if wireType == 4 {
                        return fmt.Errorf("proto: BatchInodeGetRequest: wiretype end group for non-group")
                }
                if fieldNum <= 0 {
                        return fmt.Errorf("proto: BatchInodeGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }
                switch fieldNum {
                case 1:
                        if wireType != 2 {
                                return fmt.Errorf("proto: wrong wireType = %d for field VolName", wireType)
                        }
                        var stringLen uint64
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                        intStringLen := int(stringLen)
                        if intStringLen < 0 {
                                return ErrInvalidLengthFs
                        }
                        postIndex := iNdEx + intStringLen
                        if postIndex < 0 {
                                return ErrInvalidLengthFs
                        }
                        if postIndex > l {
                                return io.ErrUnexpectedEOF
                        }
                        m.VolName = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex
                case 2:
                        if wireType != 0 {
                                return fmt.Errorf("proto: wrong wireType = %d for field PartitionID", wireType)
                        }
                        m.PartitionID = 0
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                m.PartitionID |= uint64(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                case 3:
                        if wireType == 0 {
                                var v uint64
                                for shift := uint(0); ; shift += 7 {
                                        if shift >= 64 {
                                                return ErrIntOverflowFs
                                        }
                                        if iNdEx >= l {
                                                return io.ErrUnexpectedEOF
                                        }
                                        b := dAtA[iNdEx]
                                        iNdEx++
                                        v |= uint64(b&0x7F) << shift
                                        if b < 0x80 {
                                                break
                                        }
                                }
                                m.Inodes = append(m.Inodes, v)
                        } else if wireType == 2 {
                                var packedLen int
                                for shift := uint(0); ; shift += 7 {
                                        if shift >= 64 {
                                                return ErrIntOverflowFs
                                        }
                                        if iNdEx >= l {
                                                return io.ErrUnexpectedEOF
                                        }
                                        b := dAtA[iNdEx]
                                        iNdEx++
                                        packedLen |= int(b&0x7F) << shift
                                        if b < 0x80 {
                                                break
                                        }
                                }
                                if packedLen < 0 {
                                        return ErrInvalidLengthFs
                                }
                                postIndex := iNdEx + packedLen
                                if postIndex < 0 {
                                        return ErrInvalidLengthFs
                                }
                                if postIndex > l {
                                        return io.ErrUnexpectedEOF
                                }
                                var elementCount int
                                var count int
                                for _, integer := range dAtA[iNdEx:postIndex] {
                                        if integer < 128 {
                                                count++
                                        }
                                }
                                elementCount = count
                                if elementCount != 0 && len(m.Inodes) == 0 {
                                        m.Inodes = make([]uint64, 0, elementCount)
                                }
                                for iNdEx < postIndex {
                                        var v uint64
                                        for shift := uint(0); ; shift += 7 {
                                                if shift >= 64 {
                                                        return ErrIntOverflowFs
                                                }
                                                if iNdEx >= l {
                                                        return io.ErrUnexpectedEOF
                                                }
                                                b := dAtA[iNdEx]
                                                iNdEx++
                                                v |= uint64(b&0x7F) << shift
                                                if b < 0x80 {
                                                        break
                                                }
                                        }
                                        m.Inodes = append(m.Inodes, v)
                                }
                        } else {
                                return fmt.Errorf("proto: wrong wireType = %d for field Inodes", wireType)
                        }
                case 4:
                        if wireType != 0 {
                                return fmt.Errorf("proto: wrong wireType = %d for field WithExtendAttr", wireType)
                        }
                        var v int
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                v |= int(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                        m.WithExtendAttr = bool(v != 0)
                case 5:
                        if wireType != 2 {
                                return fmt.Errorf("proto: wrong wireType = %d for field ExtendAttrKeys", wireType)
                        }
                        var stringLen uint64
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                        intStringLen := int(stringLen)
                        if intStringLen < 0 {
                                return ErrInvalidLengthFs
                        }
                        postIndex := iNdEx + intStringLen
                        if postIndex < 0 {
                                return ErrInvalidLengthFs
                        }
                        if postIndex > l {
                                return io.ErrUnexpectedEOF
                        }
                        m.ExtendAttrKeys = append(m.ExtendAttrKeys, string(dAtA[iNdEx:postIndex]))
                        iNdEx = postIndex
                default:
                        iNdEx = preIndex
                        skippy, err := skipFs(dAtA[iNdEx:])
                        if err != nil {
                                return err
                        }
                        if (skippy < 0) || (iNdEx+skippy) < 0 {
                                return ErrInvalidLengthFs
                        }
                        if (iNdEx + skippy) > l {
                                return io.ErrUnexpectedEOF
                        }
                        iNdEx += skippy
                }
        }

        if iNdEx > l {
                return io.ErrUnexpectedEOF
        }
        return nil
}
func (m *BatchInodeGetResponsePb) Unmarshal(dAtA []byte) error {
        l := len(dAtA)
        iNdEx := 0
        for iNdEx < l {
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 {
                        if shift >= 64 {
                                return ErrIntOverflowFs
                        }
                        if iNdEx >= l {
                                return io.ErrUnexpectedEOF
                        }
                        b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&0x7F) << shift
                        if b < 0x80 {
                                break
                        }
                }
                fieldNum := int32(wire >> 3)
                wireType := int(wire & 0x7)
                if wireType == 4 {
                        return fmt.Errorf("proto: BatchInodeGetResponsePb: wiretype end group for non-group")
                }
                if fieldNum <= 0 {
                        return fmt.Errorf("proto: BatchInodeGetResponsePb: illegal tag %d (wire type %d)", fieldNum, wire)
                }
                switch fieldNum {
                case 1:
                        if wireType != 2 {
                                return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
                        }
                        var msglen int
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                        if msglen < 0 {
                                return ErrInvalidLengthFs
                        }
                        postIndex := iNdEx + msglen
                        if postIndex < 0 {
                                return ErrInvalidLengthFs
                        }
                        if postIndex > l {
                                return io.ErrUnexpectedEOF
                        }
                        m.Infos = append(m.Infos, &InodeInfoPb{})
                        if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
                                return err
                        }
                        iNdEx = postIndex
                case 2:
                        if wireType != 2 {
                                return fmt.Errorf("proto: wrong wireType = %d for field ExtendAttrs", wireType)
                        }
                        var msglen int
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                        if msglen < 0 {
                                return ErrInvalidLengthFs
                        }
                        postIndex := iNdEx + msglen
                        if postIndex < 0 {
                                return ErrInvalidLengthFs
                        }
                        if postIndex > l {
                                return io.ErrUnexpectedEOF
                        }
                        m.ExtendAttrs = append(m.ExtendAttrs, &InodeExtendAttrsInfoPb{})
                        if err := m.ExtendAttrs[len(m.ExtendAttrs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
                                return err
                        }
                        iNdEx = postIndex
                default:
                        iNdEx = preIndex
                        skippy, err := skipFs(dAtA[iNdEx:])
                        if err != nil {
                                return err
                        }
                        if (skippy < 0) || (iNdEx+skippy) < 0 {
                                return ErrInvalidLengthFs
                        }
                        if (iNdEx + skippy) > l {
                                return io.ErrUnexpectedEOF
                        }
                        iNdEx += skippy
                }
        }

        if iNdEx > l {
                return io.ErrUnexpectedEOF
        }
        return nil
}
func skipFs(dAtA []byte) (n int, err error) {
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx < l {
                var wire uint64
                for shift := uint(0); ; shift += 7 {
                        if shift >= 64 {
                                return 0, ErrIntOverflowFs
                        }
                        if iNdEx >= l {
                                return 0, io.ErrUnexpectedEOF
                        }
                        b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) & 0x7F) << shift
                        if b < 0x80 {
                                break
                        }
                }
                wireType := int(wire & 0x7)
                switch wireType {
                case 0:
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return 0, ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return 0, io.ErrUnexpectedEOF
                                }
                                iNdEx++
                                if dAtA[iNdEx-1] < 0x80 {
                                        break
                                }
                        }
                case 1:
                        iNdEx += 8
                case 2:
                        var length int
                        for shift := uint(0); ; shift += 7 {
                                if shift >= 64 {
                                        return 0, ErrIntOverflowFs
                                }
                                if iNdEx >= l {
                                        return 0, io.ErrUnexpectedEOF
                                }
                                b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) & 0x7F) << shift
                                if b < 0x80 {
                                        break
                                }
                        }
                        if length < 0 {
                                return 0, ErrInvalidLengthFs
                        }
                        iNdEx += length
                case 3:
                        depth++
                case 4:
                        if depth == 0 {
                                return 0, ErrUnexpectedEndOfGroupFs
                        }
                        depth--
                case 5:
                        iNdEx += 4
                default:
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
                }
                if iNdEx < 0 {
                        return 0, ErrInvalidLengthFs
                }
                if depth == 0 {
                        return iNdEx, nil
                }
        }
        return 0, io.ErrUnexpectedEOF
}

var (
        ErrInvalidLengthFs        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowFs          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupFs = fmt.Errorf("proto: unexpected end of group")
)