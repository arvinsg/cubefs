// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: heartbeat.proto

package proto

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type MediumTypePb int32

const (
	MediumTypePb_INIT MediumTypePb = 0
	MediumTypePb_SSD  MediumTypePb = 1
	MediumTypePb_HDD  MediumTypePb = 2
	MediumTypePb_EC   MediumTypePb = 3
	MediumTypePb_SFX  MediumTypePb = 4
)

var MediumTypePb_name = map[int32]string{
	0: "INIT",
	1: "SSD",
	2: "HDD",
	3: "EC",
	4: "SFX",
}

var MediumTypePb_value = map[string]int32{
	"INIT": 0,
	"SSD":  1,
	"HDD":  2,
	"EC":   3,
	"SFX":  4,
}

func (x MediumTypePb) String() string {
	return proto.EnumName(MediumTypePb_name, int32(x))
}

func (MediumTypePb) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3c667767fb9826a9, []int{0}
}

type PartitionReportPb struct {
	VolName              string   `protobuf:"bytes,1,opt,name=VolName,proto3" json:"VolName,omitempty"`
	PartitionID          uint64   `protobuf:"varint,2,opt,name=PartitionID,proto3" json:"PartitionID,omitempty"`
	PartitionStatus      int32    `protobuf:"varint,3,opt,name=PartitionStatus,proto3" json:"PartitionStatus,omitempty"`
	Total                uint64   `protobuf:"varint,4,opt,name=Total,proto3" json:"Total,omitempty"`
	Used                 uint64   `protobuf:"varint,5,opt,name=Used,proto3" json:"Used,omitempty"`
	DiskPath             string   `protobuf:"bytes,6,opt,name=DiskPath,proto3" json:"DiskPath,omitempty"`
	IsLeader             bool     `protobuf:"varint,7,opt,name=IsLeader,proto3" json:"IsLeader,omitempty"`
	ExtentCount          int32    `protobuf:"varint,8,opt,name=ExtentCount,proto3" json:"ExtentCount,omitempty"`
	NeedCompare          bool     `protobuf:"varint,9,opt,name=NeedCompare,proto3" json:"NeedCompare,omitempty"`
	IsLearner            bool     `protobuf:"varint,10,opt,name=IsLearner,proto3" json:"IsLearner,omitempty"`
	LastUpdateTime       int64    `protobuf:"varint,11,opt,name=LastUpdateTime,proto3" json:"LastUpdateTime,omitempty"`
	IsRecover            bool     `protobuf:"varint,12,opt,name=IsRecover,proto3" json:"IsRecover,omitempty"`
	IsSFX                bool     `protobuf:"varint,13,opt,name=IsSFX,proto3" json:"IsSFX,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionReportPb) Reset()         { *m = PartitionReportPb{} }
func (m *PartitionReportPb) String() string { return proto.CompactTextString(m) }
func (*PartitionReportPb) ProtoMessage()    {}
func (*PartitionReportPb) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c667767fb9826a9, []int{0}
}
func (m *PartitionReportPb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionReportPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionReportPb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionReportPb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionReportPb.Merge(m, src)
}
func (m *PartitionReportPb) XXX_Size() int {
	return m.Size()
}
func (m *PartitionReportPb) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionReportPb.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionReportPb proto.InternalMessageInfo

func (m *PartitionReportPb) GetVolName() string {
	if m != nil {
		return m.VolName
	}
	return ""
}

func (m *PartitionReportPb) GetPartitionID() uint64 {
	if m != nil {
		return m.PartitionID
	}
	return 0
}

func (m *PartitionReportPb) GetPartitionStatus() int32 {
	if m != nil {
		return m.PartitionStatus
	}
	return 0
}

func (m *PartitionReportPb) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *PartitionReportPb) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *PartitionReportPb) GetDiskPath() string {
	if m != nil {
		return m.DiskPath
	}
	return ""
}

func (m *PartitionReportPb) GetIsLeader() bool {
	if m != nil {
		return m.IsLeader
	}
	return false
}

func (m *PartitionReportPb) GetExtentCount() int32 {
	if m != nil {
		return m.ExtentCount
	}
	return 0
}

func (m *PartitionReportPb) GetNeedCompare() bool {
	if m != nil {
		return m.NeedCompare
	}
	return false
}

func (m *PartitionReportPb) GetIsLearner() bool {
	if m != nil {
		return m.IsLearner
	}
	return false
}

func (m *PartitionReportPb) GetLastUpdateTime() int64 {
	if m != nil {
		return m.LastUpdateTime
	}
	return 0
}

func (m *PartitionReportPb) GetIsRecover() bool {
	if m != nil {
		return m.IsRecover
	}
	return false
}

func (m *PartitionReportPb) GetIsSFX() bool {
	if m != nil {
		return m.IsSFX
	}
	return false
}

type DiskInfoPb struct {
	Total                uint64   `protobuf:"varint,1,opt,name=Total,proto3" json:"Total,omitempty"`
	Used                 uint64   `protobuf:"varint,2,opt,name=Used,proto3" json:"Used,omitempty"`
	ReservedSpace        uint64   `protobuf:"varint,3,opt,name=ReservedSpace,proto3" json:"ReservedSpace,omitempty"`
	Status               int32    `protobuf:"varint,4,opt,name=Status,proto3" json:"Status,omitempty"`
	Path                 string   `protobuf:"bytes,5,opt,name=Path,proto3" json:"Path,omitempty"`
	UsageRatio           float32  `protobuf:"fixed32,6,opt,name=UsageRatio,proto3" json:"UsageRatio,omitempty"`
	IsSFX                bool     `protobuf:"varint,7,opt,name=IsSFX,proto3" json:"IsSFX,omitempty"`
	PhysicalUsedRatio    uint32   `protobuf:"varint,8,opt,name=PhysicalUsedRatio,proto3" json:"PhysicalUsedRatio,omitempty"`
	CompressionRatio     uint32   `protobuf:"varint,9,opt,name=CompressionRatio,proto3" json:"CompressionRatio,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiskInfoPb) Reset()         { *m = DiskInfoPb{} }
func (m *DiskInfoPb) String() string { return proto.CompactTextString(m) }
func (*DiskInfoPb) ProtoMessage()    {}
func (*DiskInfoPb) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c667767fb9826a9, []int{1}
}
func (m *DiskInfoPb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiskInfoPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiskInfoPb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiskInfoPb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiskInfoPb.Merge(m, src)
}
func (m *DiskInfoPb) XXX_Size() int {
	return m.Size()
}
func (m *DiskInfoPb) XXX_DiscardUnknown() {
	xxx_messageInfo_DiskInfoPb.DiscardUnknown(m)
}

var xxx_messageInfo_DiskInfoPb proto.InternalMessageInfo

func (m *DiskInfoPb) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *DiskInfoPb) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *DiskInfoPb) GetReservedSpace() uint64 {
	if m != nil {
		return m.ReservedSpace
	}
	return 0
}

func (m *DiskInfoPb) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *DiskInfoPb) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *DiskInfoPb) GetUsageRatio() float32 {
	if m != nil {
		return m.UsageRatio
	}
	return 0
}

func (m *DiskInfoPb) GetIsSFX() bool {
	if m != nil {
		return m.IsSFX
	}
	return false
}

func (m *DiskInfoPb) GetPhysicalUsedRatio() uint32 {
	if m != nil {
		return m.PhysicalUsedRatio
	}
	return 0
}

func (m *DiskInfoPb) GetCompressionRatio() uint32 {
	if m != nil {
		return m.CompressionRatio
	}
	return 0
}

type DataNodeHeartbeatResponsePb struct {
	Total                uint64                 `protobuf:"varint,1,opt,name=Total,proto3" json:"Total,omitempty"`
	Used                 uint64                 `protobuf:"varint,2,opt,name=Used,proto3" json:"Used,omitempty"`
	Available            uint64                 `protobuf:"varint,3,opt,name=Available,proto3" json:"Available,omitempty"`
	TotalPartitionSize   uint64                 `protobuf:"varint,4,opt,name=TotalPartitionSize,proto3" json:"TotalPartitionSize,omitempty"`
	RemainingCapacity    uint64                 `protobuf:"varint,5,opt,name=RemainingCapacity,proto3" json:"RemainingCapacity,omitempty"`
	CreatedPartitionCnt  uint32                 `protobuf:"varint,6,opt,name=CreatedPartitionCnt,proto3" json:"CreatedPartitionCnt,omitempty"`
	MaxCapacity          uint64                 `protobuf:"varint,7,opt,name=MaxCapacity,proto3" json:"MaxCapacity,omitempty"`
	HttpPort             string                 `protobuf:"bytes,8,opt,name=HttpPort,proto3" json:"HttpPort,omitempty"`
	ZoneName             string                 `protobuf:"bytes,9,opt,name=ZoneName,proto3" json:"ZoneName,omitempty"`
	PartitionReports     []*PartitionReportPb   `protobuf:"bytes,10,rep,name=PartitionReports,proto3" json:"PartitionReports,omitempty"`
	Status               uint32                 `protobuf:"varint,11,opt,name=Status,proto3" json:"Status,omitempty"`
	Result               string                 `protobuf:"bytes,12,opt,name=Result,proto3" json:"Result,omitempty"`
	BadDisks             []string               `protobuf:"bytes,13,rep,name=BadDisks,proto3" json:"BadDisks,omitempty"`
	DiskInfos            map[string]*DiskInfoPb `protobuf:"bytes,14,rep,name=DiskInfos,proto3" json:"DiskInfos,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Version              string                 `protobuf:"bytes,15,opt,name=Version,proto3" json:"Version,omitempty"`
	Medium               MediumTypePb           `protobuf:"varint,16,opt,name=medium,proto3,enum=proto.MediumTypePb" json:"medium,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *DataNodeHeartbeatResponsePb) Reset()         { *m = DataNodeHeartbeatResponsePb{} }
func (m *DataNodeHeartbeatResponsePb) String() string { return proto.CompactTextString(m) }
func (*DataNodeHeartbeatResponsePb) ProtoMessage()    {}
func (*DataNodeHeartbeatResponsePb) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c667767fb9826a9, []int{2}
}
func (m *DataNodeHeartbeatResponsePb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataNodeHeartbeatResponsePb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataNodeHeartbeatResponsePb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataNodeHeartbeatResponsePb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataNodeHeartbeatResponsePb.Merge(m, src)
}
func (m *DataNodeHeartbeatResponsePb) XXX_Size() int {
	return m.Size()
}
func (m *DataNodeHeartbeatResponsePb) XXX_DiscardUnknown() {
	xxx_messageInfo_DataNodeHeartbeatResponsePb.DiscardUnknown(m)
}

var xxx_messageInfo_DataNodeHeartbeatResponsePb proto.InternalMessageInfo

func (m *DataNodeHeartbeatResponsePb) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *DataNodeHeartbeatResponsePb) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *DataNodeHeartbeatResponsePb) GetAvailable() uint64 {
	if m != nil {
		return m.Available
	}
	return 0
}

func (m *DataNodeHeartbeatResponsePb) GetTotalPartitionSize() uint64 {
	if m != nil {
		return m.TotalPartitionSize
	}
	return 0
}

func (m *DataNodeHeartbeatResponsePb) GetRemainingCapacity() uint64 {
	if m != nil {
		return m.RemainingCapacity
	}
	return 0
}

func (m *DataNodeHeartbeatResponsePb) GetCreatedPartitionCnt() uint32 {
	if m != nil {
		return m.CreatedPartitionCnt
	}
	return 0
}

func (m *DataNodeHeartbeatResponsePb) GetMaxCapacity() uint64 {
	if m != nil {
		return m.MaxCapacity
	}
	return 0
}

func (m *DataNodeHeartbeatResponsePb) GetHttpPort() string {
	if m != nil {
		return m.HttpPort
	}
	return ""
}

func (m *DataNodeHeartbeatResponsePb) GetZoneName() string {
	if m != nil {
		return m.ZoneName
	}
	return ""
}

func (m *DataNodeHeartbeatResponsePb) GetPartitionReports() []*PartitionReportPb {
	if m != nil {
		return m.PartitionReports
	}
	return nil
}

func (m *DataNodeHeartbeatResponsePb) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *DataNodeHeartbeatResponsePb) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

func (m *DataNodeHeartbeatResponsePb) GetBadDisks() []string {
	if m != nil {
		return m.BadDisks
	}
	return nil
}

func (m *DataNodeHeartbeatResponsePb) GetDiskInfos() map[string]*DiskInfoPb {
	if m != nil {
		return m.DiskInfos
	}
	return nil
}

func (m *DataNodeHeartbeatResponsePb) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *DataNodeHeartbeatResponsePb) GetMedium() MediumTypePb {
	if m != nil {
		return m.Medium
	}
	return MediumTypePb_INIT
}

type MetaPartitionReportPb struct {
	PartitionID          uint64   `protobuf:"varint,1,opt,name=PartitionID,proto3" json:"PartitionID,omitempty"`
	Start                uint64   `protobuf:"varint,2,opt,name=Start,proto3" json:"Start,omitempty"`
	End                  uint64   `protobuf:"varint,3,opt,name=End,proto3" json:"End,omitempty"`
	Status               int32    `protobuf:"varint,4,opt,name=Status,proto3" json:"Status,omitempty"`
	MaxInodeID           uint64   `protobuf:"varint,5,opt,name=MaxInodeID,proto3" json:"MaxInodeID,omitempty"`
	IsLeader             bool     `protobuf:"varint,6,opt,name=IsLeader,proto3" json:"IsLeader,omitempty"`
	VolName              string   `protobuf:"bytes,7,opt,name=VolName,proto3" json:"VolName,omitempty"`
	InodeCnt             uint64   `protobuf:"varint,8,opt,name=InodeCnt,proto3" json:"InodeCnt,omitempty"`
	DentryCnt            uint64   `protobuf:"varint,9,opt,name=DentryCnt,proto3" json:"DentryCnt,omitempty"`
	DelInodeCnt          uint64   `protobuf:"varint,10,opt,name=DelInodeCnt,proto3" json:"DelInodeCnt,omitempty"`
	DelDentryCnt         uint64   `protobuf:"varint,11,opt,name=DelDentryCnt,proto3" json:"DelDentryCnt,omitempty"`
	IsLearner            bool     `protobuf:"varint,12,opt,name=IsLearner,proto3" json:"IsLearner,omitempty"`
	ExistMaxInodeID      uint64   `protobuf:"varint,13,opt,name=ExistMaxInodeID,proto3" json:"ExistMaxInodeID,omitempty"`
	StoreMode            uint32   `protobuf:"varint,14,opt,name=StoreMode,proto3" json:"StoreMode,omitempty"`
	ApplyId              uint64   `protobuf:"varint,15,opt,name=ApplyId,proto3" json:"ApplyId,omitempty"`
	IsRecover            bool     `protobuf:"varint,16,opt,name=IsRecover,proto3" json:"IsRecover,omitempty"`
	AllocatorInUseCnt    uint64   `protobuf:"varint,17,opt,name=AllocatorInUseCnt,proto3" json:"AllocatorInUseCnt,omitempty"`
	InodesTotalSize      uint64   `protobuf:"varint,18,opt,name=InodesTotalSize,proto3" json:"InodesTotalSize,omitempty"`
	DelInodesTotalSize   uint64   `protobuf:"varint,19,opt,name=DelInodesTotalSize,proto3" json:"DelInodesTotalSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetaPartitionReportPb) Reset()         { *m = MetaPartitionReportPb{} }
func (m *MetaPartitionReportPb) String() string { return proto.CompactTextString(m) }
func (*MetaPartitionReportPb) ProtoMessage()    {}
func (*MetaPartitionReportPb) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c667767fb9826a9, []int{3}
}
func (m *MetaPartitionReportPb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaPartitionReportPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetaPartitionReportPb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetaPartitionReportPb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaPartitionReportPb.Merge(m, src)
}
func (m *MetaPartitionReportPb) XXX_Size() int {
	return m.Size()
}
func (m *MetaPartitionReportPb) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaPartitionReportPb.DiscardUnknown(m)
}

var xxx_messageInfo_MetaPartitionReportPb proto.InternalMessageInfo

func (m *MetaPartitionReportPb) GetPartitionID() uint64 {
	if m != nil {
		return m.PartitionID
	}
	return 0
}

func (m *MetaPartitionReportPb) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *MetaPartitionReportPb) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *MetaPartitionReportPb) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *MetaPartitionReportPb) GetMaxInodeID() uint64 {
	if m != nil {
		return m.MaxInodeID
	}
	return 0
}

func (m *MetaPartitionReportPb) GetIsLeader() bool {
	if m != nil {
		return m.IsLeader
	}
	return false
}

func (m *MetaPartitionReportPb) GetVolName() string {
	if m != nil {
		return m.VolName
	}
	return ""
}

func (m *MetaPartitionReportPb) GetInodeCnt() uint64 {
	if m != nil {
		return m.InodeCnt
	}
	return 0
}

func (m *MetaPartitionReportPb) GetDentryCnt() uint64 {
	if m != nil {
		return m.DentryCnt
	}
	return 0
}

func (m *MetaPartitionReportPb) GetDelInodeCnt() uint64 {
	if m != nil {
		return m.DelInodeCnt
	}
	return 0
}

func (m *MetaPartitionReportPb) GetDelDentryCnt() uint64 {
	if m != nil {
		return m.DelDentryCnt
	}
	return 0
}

func (m *MetaPartitionReportPb) GetIsLearner() bool {
	if m != nil {
		return m.IsLearner
	}
	return false
}

func (m *MetaPartitionReportPb) GetExistMaxInodeID() uint64 {
	if m != nil {
		return m.ExistMaxInodeID
	}
	return 0
}

func (m *MetaPartitionReportPb) GetStoreMode() uint32 {
	if m != nil {
		return m.StoreMode
	}
	return 0
}

func (m *MetaPartitionReportPb) GetApplyId() uint64 {
	if m != nil {
		return m.ApplyId
	}
	return 0
}

func (m *MetaPartitionReportPb) GetIsRecover() bool {
	if m != nil {
		return m.IsRecover
	}
	return false
}

func (m *MetaPartitionReportPb) GetAllocatorInUseCnt() uint64 {
	if m != nil {
		return m.AllocatorInUseCnt
	}
	return 0
}

func (m *MetaPartitionReportPb) GetInodesTotalSize() uint64 {
	if m != nil {
		return m.InodesTotalSize
	}
	return 0
}

func (m *MetaPartitionReportPb) GetDelInodesTotalSize() uint64 {
	if m != nil {
		return m.DelInodesTotalSize
	}
	return 0
}

type MetaNodeDiskInfoPb struct {
	Path                 string   `protobuf:"bytes,1,opt,name=Path,proto3" json:"Path,omitempty"`
	Total                uint64   `protobuf:"varint,2,opt,name=Total,proto3" json:"Total,omitempty"`
	Used                 uint64   `protobuf:"varint,3,opt,name=Used,proto3" json:"Used,omitempty"`
	UsageRatio           float32  `protobuf:"fixed32,4,opt,name=UsageRatio,proto3" json:"UsageRatio,omitempty"`
	Status               int32    `protobuf:"varint,5,opt,name=Status,proto3" json:"Status,omitempty"`
	MPCount              int32    `protobuf:"varint,6,opt,name=MPCount,proto3" json:"MPCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetaNodeDiskInfoPb) Reset()         { *m = MetaNodeDiskInfoPb{} }
func (m *MetaNodeDiskInfoPb) String() string { return proto.CompactTextString(m) }
func (*MetaNodeDiskInfoPb) ProtoMessage()    {}
func (*MetaNodeDiskInfoPb) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c667767fb9826a9, []int{4}
}
func (m *MetaNodeDiskInfoPb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaNodeDiskInfoPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetaNodeDiskInfoPb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetaNodeDiskInfoPb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaNodeDiskInfoPb.Merge(m, src)
}
func (m *MetaNodeDiskInfoPb) XXX_Size() int {
	return m.Size()
}
func (m *MetaNodeDiskInfoPb) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaNodeDiskInfoPb.DiscardUnknown(m)
}

var xxx_messageInfo_MetaNodeDiskInfoPb proto.InternalMessageInfo

func (m *MetaNodeDiskInfoPb) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *MetaNodeDiskInfoPb) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *MetaNodeDiskInfoPb) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *MetaNodeDiskInfoPb) GetUsageRatio() float32 {
	if m != nil {
		return m.UsageRatio
	}
	return 0
}

func (m *MetaNodeDiskInfoPb) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *MetaNodeDiskInfoPb) GetMPCount() int32 {
	if m != nil {
		return m.MPCount
	}
	return 0
}

type MetaNodeHeartbeatResponsePb struct {
	ZoneName             string                   `protobuf:"bytes,1,opt,name=ZoneName,proto3" json:"ZoneName,omitempty"`
	Total                uint64                   `protobuf:"varint,2,opt,name=Total,proto3" json:"Total,omitempty"`
	Used                 uint64                   `protobuf:"varint,3,opt,name=Used,proto3" json:"Used,omitempty"`
	MetaPartitionReports []*MetaPartitionReportPb `protobuf:"bytes,4,rep,name=MetaPartitionReports,proto3" json:"MetaPartitionReports,omitempty"`
	Status               uint32                   `protobuf:"varint,5,opt,name=Status,proto3" json:"Status,omitempty"`
	ProfPort             string                   `protobuf:"bytes,6,opt,name=ProfPort,proto3" json:"ProfPort,omitempty"`
	Result               string                   `protobuf:"bytes,7,opt,name=Result,proto3" json:"Result,omitempty"`
	RocksDBDiskInfo      []*MetaNodeDiskInfoPb    `protobuf:"bytes,8,rep,name=RocksDBDiskInfo,proto3" json:"RocksDBDiskInfo,omitempty"`
	Version              string                   `protobuf:"bytes,9,opt,name=Version,proto3" json:"Version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *MetaNodeHeartbeatResponsePb) Reset()         { *m = MetaNodeHeartbeatResponsePb{} }
func (m *MetaNodeHeartbeatResponsePb) String() string { return proto.CompactTextString(m) }
func (*MetaNodeHeartbeatResponsePb) ProtoMessage()    {}
func (*MetaNodeHeartbeatResponsePb) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c667767fb9826a9, []int{5}
}
func (m *MetaNodeHeartbeatResponsePb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaNodeHeartbeatResponsePb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetaNodeHeartbeatResponsePb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetaNodeHeartbeatResponsePb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaNodeHeartbeatResponsePb.Merge(m, src)
}
func (m *MetaNodeHeartbeatResponsePb) XXX_Size() int {
	return m.Size()
}
func (m *MetaNodeHeartbeatResponsePb) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaNodeHeartbeatResponsePb.DiscardUnknown(m)
}

var xxx_messageInfo_MetaNodeHeartbeatResponsePb proto.InternalMessageInfo

func (m *MetaNodeHeartbeatResponsePb) GetZoneName() string {
	if m != nil {
		return m.ZoneName
	}
	return ""
}

func (m *MetaNodeHeartbeatResponsePb) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *MetaNodeHeartbeatResponsePb) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *MetaNodeHeartbeatResponsePb) GetMetaPartitionReports() []*MetaPartitionReportPb {
	if m != nil {
		return m.MetaPartitionReports
	}
	return nil
}

func (m *MetaNodeHeartbeatResponsePb) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *MetaNodeHeartbeatResponsePb) GetProfPort() string {
	if m != nil {
		return m.ProfPort
	}
	return ""
}

func (m *MetaNodeHeartbeatResponsePb) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

func (m *MetaNodeHeartbeatResponsePb) GetRocksDBDiskInfo() []*MetaNodeDiskInfoPb {
	if m != nil {
		return m.RocksDBDiskInfo
	}
	return nil
}

func (m *MetaNodeHeartbeatResponsePb) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type HeartBeatRequestPb struct {
	CurrTime             int64    `protobuf:"varint,1,opt,name=CurrTime,proto3" json:"CurrTime,omitempty"`
	MasterAddr           string   `protobuf:"bytes,2,opt,name=MasterAddr,proto3" json:"MasterAddr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeartBeatRequestPb) Reset()         { *m = HeartBeatRequestPb{} }
func (m *HeartBeatRequestPb) String() string { return proto.CompactTextString(m) }
func (*HeartBeatRequestPb) ProtoMessage()    {}
func (*HeartBeatRequestPb) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c667767fb9826a9, []int{6}
}
func (m *HeartBeatRequestPb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartBeatRequestPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartBeatRequestPb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeartBeatRequestPb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartBeatRequestPb.Merge(m, src)
}
func (m *HeartBeatRequestPb) XXX_Size() int {
	return m.Size()
}
func (m *HeartBeatRequestPb) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartBeatRequestPb.DiscardUnknown(m)
}

var xxx_messageInfo_HeartBeatRequestPb proto.InternalMessageInfo

func (m *HeartBeatRequestPb) GetCurrTime() int64 {
	if m != nil {
		return m.CurrTime
	}
	return 0
}

func (m *HeartBeatRequestPb) GetMasterAddr() string {
	if m != nil {
		return m.MasterAddr
	}
	return ""
}

type HeartbeatAdminTaskPb struct {
	ID                   string                       `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	PartitionID          uint64                       `protobuf:"varint,2,opt,name=PartitionID,proto3" json:"PartitionID,omitempty"`
	OpCode               uint32                       `protobuf:"varint,3,opt,name=OpCode,proto3" json:"OpCode,omitempty"`
	OperatorAddr         string                       `protobuf:"bytes,4,opt,name=OperatorAddr,proto3" json:"OperatorAddr,omitempty"`
	Status               int32                        `protobuf:"varint,5,opt,name=Status,proto3" json:"Status,omitempty"`
	SendTime             int64                        `protobuf:"varint,6,opt,name=SendTime,proto3" json:"SendTime,omitempty"`
	CreateTime           int64                        `protobuf:"varint,7,opt,name=CreateTime,proto3" json:"CreateTime,omitempty"`
	SendCount            uint32                       `protobuf:"varint,8,opt,name=SendCount,proto3" json:"SendCount,omitempty"`
	ReserveResource      bool                         `protobuf:"varint,9,opt,name=ReserveResource,proto3" json:"ReserveResource,omitempty"`
	Request              *HeartBeatRequestPb          `protobuf:"bytes,10,opt,name=Request,proto3" json:"Request,omitempty"`
	MetaNodeResponse     *MetaNodeHeartbeatResponsePb `protobuf:"bytes,11,opt,name=MetaNodeResponse,proto3" json:"MetaNodeResponse,omitempty"`
	DataNodeResponse     *DataNodeHeartbeatResponsePb `protobuf:"bytes,12,opt,name=DataNodeResponse,proto3" json:"DataNodeResponse,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *HeartbeatAdminTaskPb) Reset()         { *m = HeartbeatAdminTaskPb{} }
func (m *HeartbeatAdminTaskPb) String() string { return proto.CompactTextString(m) }
func (*HeartbeatAdminTaskPb) ProtoMessage()    {}
func (*HeartbeatAdminTaskPb) Descriptor() ([]byte, []int) {
	return fileDescriptor_3c667767fb9826a9, []int{7}
}
func (m *HeartbeatAdminTaskPb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatAdminTaskPb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartbeatAdminTaskPb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeartbeatAdminTaskPb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatAdminTaskPb.Merge(m, src)
}
func (m *HeartbeatAdminTaskPb) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatAdminTaskPb) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatAdminTaskPb.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatAdminTaskPb proto.InternalMessageInfo

func (m *HeartbeatAdminTaskPb) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *HeartbeatAdminTaskPb) GetPartitionID() uint64 {
	if m != nil {
		return m.PartitionID
	}
	return 0
}

func (m *HeartbeatAdminTaskPb) GetOpCode() uint32 {
	if m != nil {
		return m.OpCode
	}
	return 0
}

func (m *HeartbeatAdminTaskPb) GetOperatorAddr() string {
	if m != nil {
		return m.OperatorAddr
	}
	return ""
}

func (m *HeartbeatAdminTaskPb) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *HeartbeatAdminTaskPb) GetSendTime() int64 {
	if m != nil {
		return m.SendTime
	}
	return 0
}

func (m *HeartbeatAdminTaskPb) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *HeartbeatAdminTaskPb) GetSendCount() uint32 {
	if m != nil {
		return m.SendCount
	}
	return 0
}

func (m *HeartbeatAdminTaskPb) GetReserveResource() bool {
	if m != nil {
		return m.ReserveResource
	}
	return false
}

func (m *HeartbeatAdminTaskPb) GetRequest() *HeartBeatRequestPb {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *HeartbeatAdminTaskPb) GetMetaNodeResponse() *MetaNodeHeartbeatResponsePb {
	if m != nil {
		return m.MetaNodeResponse
	}
	return nil
}

func (m *HeartbeatAdminTaskPb) GetDataNodeResponse() *DataNodeHeartbeatResponsePb {
	if m != nil {
		return m.DataNodeResponse
	}
	return nil
}

func init() {
	proto.RegisterEnum("proto.MediumTypePb", MediumTypePb_name, MediumTypePb_value)
	proto.RegisterType((*PartitionReportPb)(nil), "proto.PartitionReportPb")
	proto.RegisterType((*DiskInfoPb)(nil), "proto.DiskInfoPb")
	proto.RegisterType((*DataNodeHeartbeatResponsePb)(nil), "proto.DataNodeHeartbeatResponsePb")
	proto.RegisterMapType((map[string]*DiskInfoPb)(nil), "proto.DataNodeHeartbeatResponsePb.DiskInfosEntry")
	proto.RegisterType((*MetaPartitionReportPb)(nil), "proto.MetaPartitionReportPb")
	proto.RegisterType((*MetaNodeDiskInfoPb)(nil), "proto.MetaNodeDiskInfoPb")
	proto.RegisterType((*MetaNodeHeartbeatResponsePb)(nil), "proto.MetaNodeHeartbeatResponsePb")
	proto.RegisterType((*HeartBeatRequestPb)(nil), "proto.HeartBeatRequestPb")
	proto.RegisterType((*HeartbeatAdminTaskPb)(nil), "proto.HeartbeatAdminTaskPb")
}

func init() { proto.RegisterFile("heartbeat.proto", fileDescriptor_3c667767fb9826a9) }

var fileDescriptor_3c667767fb9826a9 = []byte{
	// 1277 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xcb, 0x6e, 0x1b, 0xc7,
	0x12, 0xf5, 0xf0, 0x3d, 0x45, 0x3d, 0xa8, 0xb6, 0xae, 0x31, 0x57, 0x36, 0x04, 0x82, 0xb8, 0xb8,
	0x97, 0xf0, 0x35, 0x84, 0x44, 0xde, 0x04, 0xc9, 0x4a, 0xe2, 0xc8, 0x30, 0x01, 0x4b, 0x22, 0x9a,
	0x52, 0x60, 0x64, 0xd7, 0xe4, 0x94, 0xed, 0x81, 0xc8, 0x99, 0x49, 0x77, 0x53, 0x90, 0xf2, 0x25,
	0xce, 0x3e, 0x1f, 0x13, 0x64, 0x95, 0x4f, 0x30, 0x9c, 0x6f, 0xf0, 0x3e, 0xe8, 0x9a, 0x07, 0xe7,
	0x41, 0x1b, 0xce, 0x8a, 0x53, 0xa7, 0xba, 0x8b, 0x55, 0xd5, 0xa7, 0x4e, 0x37, 0xec, 0xbe, 0x43,
	0x21, 0xf5, 0x0c, 0x85, 0x3e, 0x8a, 0x64, 0xa8, 0x43, 0xd6, 0xa4, 0x9f, 0xc1, 0xaf, 0x75, 0xd8,
	0x9b, 0x08, 0xa9, 0x7d, 0xed, 0x87, 0x01, 0xc7, 0x28, 0x94, 0x7a, 0x32, 0x63, 0x0e, 0xb4, 0x7f,
	0x0c, 0x17, 0x17, 0x62, 0x89, 0x8e, 0xd5, 0xb7, 0x86, 0x36, 0x4f, 0x4d, 0xd6, 0x87, 0x6e, 0xb6,
	0x7c, 0xec, 0x3a, 0xb5, 0xbe, 0x35, 0x6c, 0xf0, 0x3c, 0xc4, 0x86, 0xb0, 0x9b, 0x99, 0x53, 0x2d,
	0xf4, 0x4a, 0x39, 0xf5, 0xbe, 0x35, 0x6c, 0xf2, 0x32, 0xcc, 0xf6, 0xa1, 0x79, 0x15, 0x6a, 0xb1,
	0x70, 0x1a, 0x14, 0x25, 0x36, 0x18, 0x83, 0xc6, 0xb5, 0x42, 0xcf, 0x69, 0x12, 0x48, 0xdf, 0xec,
	0x00, 0x3a, 0xae, 0xaf, 0x6e, 0x26, 0x42, 0xbf, 0x73, 0x5a, 0x94, 0x50, 0x66, 0x1b, 0xdf, 0x58,
	0xbd, 0x42, 0xe1, 0xa1, 0x74, 0xda, 0x7d, 0x6b, 0xd8, 0xe1, 0x99, 0x6d, 0xb2, 0x3d, 0xbb, 0xd3,
	0x18, 0xe8, 0x51, 0xb8, 0x0a, 0xb4, 0xd3, 0xa1, 0x3c, 0xf2, 0x90, 0x59, 0x71, 0x81, 0xe8, 0x8d,
	0xc2, 0x65, 0x24, 0x24, 0x3a, 0x36, 0x05, 0xc8, 0x43, 0xec, 0x09, 0xd8, 0x14, 0x4f, 0x06, 0x28,
	0x1d, 0x20, 0xff, 0x1a, 0x60, 0xff, 0x85, 0x9d, 0x57, 0x42, 0xe9, 0xeb, 0xc8, 0x13, 0x1a, 0xaf,
	0xfc, 0x25, 0x3a, 0xdd, 0xbe, 0x35, 0xac, 0xf3, 0x12, 0x1a, 0x47, 0xe1, 0x38, 0x0f, 0x6f, 0x51,
	0x3a, 0x5b, 0x69, 0x94, 0x04, 0x30, 0x9d, 0x18, 0xab, 0xe9, 0x8b, 0xd7, 0xce, 0x36, 0x79, 0x62,
	0x63, 0xf0, 0xbe, 0x06, 0x60, 0xca, 0x1c, 0x07, 0x6f, 0xc2, 0xc9, 0x6c, 0xdd, 0x2e, 0x6b, 0x53,
	0xbb, 0x6a, 0xb9, 0x76, 0xfd, 0x07, 0xb6, 0x39, 0x2a, 0x94, 0xb7, 0xe8, 0x4d, 0x23, 0x31, 0x47,
	0x3a, 0x80, 0x06, 0x2f, 0x82, 0xec, 0x11, 0xb4, 0x92, 0xf3, 0x69, 0x50, 0x5f, 0x12, 0xcb, 0x44,
	0xa4, 0x46, 0x37, 0xa9, 0xd1, 0xf4, 0xcd, 0x0e, 0x01, 0xae, 0x95, 0x78, 0x8b, 0x5c, 0x68, 0x3f,
	0xa4, 0x23, 0xa8, 0xf1, 0x1c, 0xb2, 0x2e, 0xa0, 0x9d, 0x2b, 0x80, 0x3d, 0x83, 0xbd, 0xc9, 0xbb,
	0x7b, 0xe5, 0xcf, 0xc5, 0xc2, 0xe4, 0x15, 0x6f, 0x36, 0x87, 0xb0, 0xcd, 0xab, 0x0e, 0xf6, 0x14,
	0x7a, 0xa6, 0xe7, 0x12, 0x95, 0x32, 0x5c, 0xa4, 0xc5, 0x36, 0x2d, 0xae, 0xe0, 0x83, 0x3f, 0x9a,
	0xf0, 0xd8, 0x15, 0x5a, 0x5c, 0x84, 0x1e, 0xbe, 0x4c, 0x99, 0xcd, 0x51, 0x45, 0x61, 0xa0, 0xf0,
	0x1f, 0xf5, 0xea, 0x09, 0xd8, 0x27, 0xb7, 0xc2, 0x5f, 0x88, 0xd9, 0x22, 0xed, 0xd3, 0x1a, 0x60,
	0x47, 0xc0, 0x68, 0xeb, 0x9a, 0xba, 0xfe, 0x2f, 0x98, 0xf0, 0x75, 0x83, 0xc7, 0x54, 0xcc, 0x71,
	0x29, 0xfc, 0xc0, 0x0f, 0xde, 0x8e, 0x44, 0x24, 0xe6, 0xbe, 0xbe, 0x4f, 0x98, 0x5c, 0x75, 0xb0,
	0x6f, 0xe0, 0xe1, 0x48, 0xa2, 0xd0, 0xe8, 0x65, 0x51, 0x46, 0x81, 0xa6, 0xf6, 0x6e, 0xf3, 0x4d,
	0x2e, 0x43, 0xd7, 0x73, 0x71, 0x97, 0x45, 0x6e, 0xc7, 0xe3, 0x97, 0x83, 0xcc, 0x38, 0xbc, 0xd4,
	0x3a, 0x9a, 0x84, 0x32, 0xe6, 0xbb, 0xcd, 0x33, 0xdb, 0xf8, 0x7e, 0x0a, 0x03, 0xa4, 0xb9, 0xb6,
	0x63, 0x5f, 0x6a, 0x33, 0x17, 0x7a, 0x25, 0x1d, 0x50, 0x0e, 0xf4, 0xeb, 0xc3, 0xee, 0xb1, 0x13,
	0x2b, 0xc6, 0x51, 0x45, 0x26, 0x78, 0x65, 0x47, 0x8e, 0x53, 0x5d, 0x2a, 0x22, 0xe5, 0xd4, 0x23,
	0x68, 0x71, 0x54, 0xab, 0x85, 0x26, 0xee, 0xdb, 0x3c, 0xb1, 0x4c, 0x46, 0xa7, 0xc2, 0x33, 0x24,
	0x57, 0xce, 0x76, 0xbf, 0x6e, 0x32, 0x4a, 0x6d, 0x76, 0x09, 0x76, 0xca, 0x7e, 0xe5, 0xec, 0x50,
	0x2a, 0xdf, 0x26, 0xa9, 0x7c, 0xe1, 0xe8, 0x8f, 0xb2, 0x3d, 0x67, 0x81, 0x96, 0xf7, 0x7c, 0x1d,
	0x83, 0x54, 0x0d, 0xa5, 0x21, 0x91, 0xb3, 0x9b, 0xa8, 0x5a, 0x6c, 0xb2, 0xff, 0x43, 0x6b, 0x89,
	0x9e, 0xbf, 0x5a, 0x3a, 0xbd, 0xbe, 0x35, 0xdc, 0x39, 0x7e, 0x98, 0xfc, 0xcf, 0x39, 0x81, 0x57,
	0xf7, 0x11, 0x4e, 0x66, 0x3c, 0x59, 0x72, 0x70, 0x09, 0x3b, 0xc5, 0xff, 0x60, 0x3d, 0xa8, 0xdf,
	0xe0, 0x7d, 0x22, 0x95, 0xe6, 0x93, 0xfd, 0x0f, 0x9a, 0xb7, 0x62, 0xb1, 0x42, 0xa2, 0x5a, 0xf7,
	0x78, 0x2f, 0xcd, 0x3b, 0x9b, 0x66, 0x1e, 0xfb, 0xbf, 0xaf, 0x7d, 0x67, 0x0d, 0x3e, 0x35, 0xe0,
	0x5f, 0xe7, 0xa8, 0x45, 0x55, 0x87, 0x4b, 0x6a, 0x6b, 0x55, 0xd5, 0x76, 0x1f, 0x9a, 0x53, 0x2d,
	0xa4, 0x4e, 0x38, 0x1d, 0x1b, 0x26, 0xa1, 0xb3, 0xc0, 0x4b, 0xe8, 0x6c, 0x3e, 0x3f, 0x3b, 0xec,
	0x87, 0x00, 0xe7, 0xe2, 0x6e, 0x1c, 0x84, 0x1e, 0x8e, 0xdd, 0x84, 0xa9, 0x39, 0xa4, 0xa0, 0xae,
	0xad, 0x92, 0xba, 0xe6, 0x6e, 0x89, 0x76, 0xf1, 0x96, 0x30, 0xbb, 0x4c, 0x80, 0x51, 0x22, 0xba,
	0x0d, 0x9e, 0xd9, 0x66, 0xe0, 0x5c, 0x34, 0x6d, 0x33, 0x4e, 0x3b, 0x1e, 0xb8, 0x0c, 0x30, 0x15,
	0xbb, 0xb8, 0xc8, 0x36, 0x43, 0x5c, 0x71, 0x0e, 0x62, 0x03, 0xd8, 0x72, 0x71, 0xb1, 0x0e, 0xd1,
	0xa5, 0x25, 0x05, 0xac, 0xa8, 0xd9, 0x5b, 0x65, 0xcd, 0x1e, 0xc2, 0xee, 0xd9, 0x9d, 0xaf, 0x74,
	0xae, 0xf0, 0x6d, 0x0a, 0x52, 0x86, 0x4d, 0x9c, 0xa9, 0x0e, 0x25, 0x9e, 0x87, 0x1e, 0x3a, 0x3b,
	0xc4, 0xe8, 0x35, 0x60, 0xea, 0x3f, 0x89, 0xa2, 0xc5, 0xfd, 0xd8, 0x23, 0x3e, 0x35, 0x78, 0x6a,
	0x16, 0xd5, 0xbe, 0x57, 0x56, 0xfb, 0x67, 0xb0, 0x77, 0xb2, 0x58, 0x84, 0x73, 0xa1, 0x43, 0x39,
	0x0e, 0xae, 0x15, 0x55, 0xba, 0x17, 0x8b, 0x44, 0xc5, 0x61, 0xb2, 0xa5, 0x74, 0x14, 0xc9, 0x0d,
	0xe9, 0x0f, 0x8b, 0xb3, 0x2d, 0xc1, 0x46, 0xac, 0xd2, 0x46, 0xe5, 0x16, 0x3f, 0x8c, 0xc5, 0xaa,
	0xea, 0x19, 0xfc, 0x66, 0x01, 0x33, 0xbc, 0x33, 0x93, 0x94, 0xbb, 0x67, 0x52, 0xfd, 0xb7, 0x72,
	0xfa, 0x9f, 0xe9, 0x69, 0x6d, 0x93, 0x9e, 0xd6, 0x73, 0x7a, 0x5a, 0xbc, 0x29, 0x1a, 0x95, 0x9b,
	0x62, 0x4d, 0xc4, 0x66, 0x81, 0x88, 0x0e, 0xb4, 0xcf, 0x27, 0xf1, 0x35, 0xdd, 0x22, 0x47, 0x6a,
	0x0e, 0x3e, 0xd4, 0xe0, 0x71, 0x9a, 0xe6, 0x26, 0xad, 0xcf, 0xab, 0x9a, 0x55, 0x52, 0xb5, 0xaf,
	0xcf, 0x7b, 0x02, 0xfb, 0x1b, 0x66, 0xd0, 0x8c, 0x8b, 0x11, 0x9e, 0x27, 0x99, 0x20, 0x6c, 0x18,
	0x53, 0xbe, 0x71, 0x67, 0xa9, 0xd2, 0xb5, 0x16, 0x1e, 0x40, 0x67, 0x22, 0xc3, 0x37, 0xa4, 0xd0,
	0xc9, 0x63, 0x26, 0xb5, 0x73, 0x3a, 0xd9, 0x2e, 0xe8, 0xe4, 0x08, 0x76, 0x79, 0x38, 0xbf, 0x51,
	0xee, 0x69, 0x7a, 0x50, 0x4e, 0x87, 0x12, 0xfb, 0x77, 0x2e, 0xb1, 0xe2, 0x39, 0xf2, 0xf2, 0x8e,
	0xbc, 0xfe, 0xd9, 0x05, 0xfd, 0x1b, 0x4c, 0x80, 0x51, 0x67, 0x4f, 0xa9, 0xb3, 0x3f, 0xaf, 0x50,
	0xe9, 0xb8, 0xb1, 0xa3, 0x95, 0x94, 0xf4, 0xaa, 0xb1, 0xe8, 0x55, 0x93, 0xd9, 0xb1, 0x6e, 0x28,
	0x8d, 0xf2, 0xc4, 0xf3, 0x24, 0x75, 0xd7, 0xe6, 0x39, 0x64, 0xf0, 0xa9, 0x0e, 0xfb, 0xd9, 0x61,
	0x9d, 0x78, 0x4b, 0x3f, 0xb8, 0x12, 0xea, 0x66, 0x32, 0x63, 0x3b, 0x50, 0x4b, 0x94, 0xcc, 0xe6,
	0xb5, 0xb1, 0xfb, 0x15, 0x0f, 0xca, 0x47, 0xd0, 0xba, 0x8c, 0x46, 0x66, 0x02, 0xeb, 0x71, 0x1f,
	0x63, 0xcb, 0x08, 0xc1, 0x65, 0x84, 0xd2, 0x0c, 0x0b, 0x25, 0xd1, 0xa0, 0x98, 0x05, 0xec, 0xb3,
	0x6c, 0x3b, 0x80, 0xce, 0x14, 0x03, 0x8f, 0x4a, 0x6b, 0xc5, 0xa5, 0xa5, 0xb6, 0x29, 0x2d, 0xbe,
	0x7a, 0xc9, 0xdb, 0x26, 0x6f, 0x0e, 0x21, 0x51, 0xc0, 0xc0, 0x5b, 0x3f, 0x29, 0x8d, 0x28, 0xa4,
	0x80, 0x19, 0xd7, 0xe4, 0x99, 0xc5, 0x51, 0x85, 0x2b, 0x39, 0x4f, 0x1f, 0x95, 0x65, 0x98, 0x3d,
	0x87, 0x76, 0xd2, 0x6b, 0x92, 0xb9, 0xf5, 0x59, 0x56, 0x8f, 0x82, 0xa7, 0x2b, 0xd9, 0x05, 0xf4,
	0xd2, 0xa3, 0x4e, 0x47, 0x80, 0x14, 0xb0, 0x7b, 0x3c, 0x28, 0x31, 0x61, 0xc3, 0xa8, 0xf0, 0xca,
	0x5e, 0x13, 0x2f, 0xbd, 0x4c, 0xb3, 0x78, 0x5b, 0x85, 0x78, 0x5f, 0xb8, 0x6b, 0x79, 0x65, 0xef,
	0xd3, 0x1f, 0x60, 0x2b, 0x7f, 0x69, 0xb2, 0x0e, 0x34, 0xc6, 0x17, 0xe3, 0xab, 0xde, 0x03, 0xd6,
	0x86, 0xfa, 0x74, 0xea, 0xf6, 0x2c, 0xf3, 0xf1, 0xd2, 0x75, 0x7b, 0x35, 0xd6, 0x82, 0xda, 0xd9,
	0xa8, 0x57, 0x27, 0xcf, 0x8b, 0xd7, 0xbd, 0xc6, 0x69, 0xef, 0xf7, 0x8f, 0x87, 0xd6, 0x9f, 0x1f,
	0x0f, 0xad, 0x0f, 0x1f, 0x0f, 0xad, 0xf7, 0x7f, 0x1d, 0x3e, 0x98, 0xb5, 0x28, 0x87, 0xe7, 0x7f,
	0x07, 0x00, 0x00, 0xff, 0xff, 0x2f, 0x8b, 0xbd, 0x59, 0xbf, 0x0c, 0x00, 0x00,
}

func (m *PartitionReportPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionReportPb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionReportPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsSFX {
		i--
		if m.IsSFX {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.IsRecover {
		i--
		if m.IsRecover {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.LastUpdateTime != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.LastUpdateTime))
		i--
		dAtA[i] = 0x58
	}
	if m.IsLearner {
		i--
		if m.IsLearner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.NeedCompare {
		i--
		if m.NeedCompare {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.ExtentCount != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.ExtentCount))
		i--
		dAtA[i] = 0x40
	}
	if m.IsLeader {
		i--
		if m.IsLeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.DiskPath) > 0 {
		i -= len(m.DiskPath)
		copy(dAtA[i:], m.DiskPath)
		i = encodeVarintHeartbeat(dAtA, i, uint64(len(m.DiskPath)))
		i--
		dAtA[i] = 0x32
	}
	if m.Used != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.Used))
		i--
		dAtA[i] = 0x28
	}
	if m.Total != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x20
	}
	if m.PartitionStatus != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.PartitionStatus))
		i--
		dAtA[i] = 0x18
	}
	if m.PartitionID != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.PartitionID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.VolName) > 0 {
		i -= len(m.VolName)
		copy(dAtA[i:], m.VolName)
		i = encodeVarintHeartbeat(dAtA, i, uint64(len(m.VolName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DiskInfoPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskInfoPb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiskInfoPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CompressionRatio != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.CompressionRatio))
		i--
		dAtA[i] = 0x48
	}
	if m.PhysicalUsedRatio != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.PhysicalUsedRatio))
		i--
		dAtA[i] = 0x40
	}
	if m.IsSFX {
		i--
		if m.IsSFX {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.UsageRatio != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UsageRatio))))
		i--
		dAtA[i] = 0x35
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintHeartbeat(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.ReservedSpace != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.ReservedSpace))
		i--
		dAtA[i] = 0x18
	}
	if m.Used != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.Used))
		i--
		dAtA[i] = 0x10
	}
	if m.Total != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataNodeHeartbeatResponsePb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataNodeHeartbeatResponsePb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataNodeHeartbeatResponsePb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Medium != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.Medium))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintHeartbeat(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.DiskInfos) > 0 {
		for k := range m.DiskInfos {
			v := m.DiskInfos[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintHeartbeat(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintHeartbeat(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintHeartbeat(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.BadDisks) > 0 {
		for iNdEx := len(m.BadDisks) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BadDisks[iNdEx])
			copy(dAtA[i:], m.BadDisks[iNdEx])
			i = encodeVarintHeartbeat(dAtA, i, uint64(len(m.BadDisks[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintHeartbeat(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x62
	}
	if m.Status != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x58
	}
	if len(m.PartitionReports) > 0 {
		for iNdEx := len(m.PartitionReports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PartitionReports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHeartbeat(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.ZoneName) > 0 {
		i -= len(m.ZoneName)
		copy(dAtA[i:], m.ZoneName)
		i = encodeVarintHeartbeat(dAtA, i, uint64(len(m.ZoneName)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.HttpPort) > 0 {
		i -= len(m.HttpPort)
		copy(dAtA[i:], m.HttpPort)
		i = encodeVarintHeartbeat(dAtA, i, uint64(len(m.HttpPort)))
		i--
		dAtA[i] = 0x42
	}
	if m.MaxCapacity != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.MaxCapacity))
		i--
		dAtA[i] = 0x38
	}
	if m.CreatedPartitionCnt != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.CreatedPartitionCnt))
		i--
		dAtA[i] = 0x30
	}
	if m.RemainingCapacity != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.RemainingCapacity))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalPartitionSize != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.TotalPartitionSize))
		i--
		dAtA[i] = 0x20
	}
	if m.Available != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.Available))
		i--
		dAtA[i] = 0x18
	}
	if m.Used != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.Used))
		i--
		dAtA[i] = 0x10
	}
	if m.Total != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MetaPartitionReportPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaPartitionReportPb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaPartitionReportPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DelInodesTotalSize != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.DelInodesTotalSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.InodesTotalSize != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.InodesTotalSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.AllocatorInUseCnt != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.AllocatorInUseCnt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.IsRecover {
		i--
		if m.IsRecover {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.ApplyId != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.ApplyId))
		i--
		dAtA[i] = 0x78
	}
	if m.StoreMode != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.StoreMode))
		i--
		dAtA[i] = 0x70
	}
	if m.ExistMaxInodeID != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.ExistMaxInodeID))
		i--
		dAtA[i] = 0x68
	}
	if m.IsLearner {
		i--
		if m.IsLearner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.DelDentryCnt != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.DelDentryCnt))
		i--
		dAtA[i] = 0x58
	}
	if m.DelInodeCnt != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.DelInodeCnt))
		i--
		dAtA[i] = 0x50
	}
	if m.DentryCnt != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.DentryCnt))
		i--
		dAtA[i] = 0x48
	}
	if m.InodeCnt != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.InodeCnt))
		i--
		dAtA[i] = 0x40
	}
	if len(m.VolName) > 0 {
		i -= len(m.VolName)
		copy(dAtA[i:], m.VolName)
		i = encodeVarintHeartbeat(dAtA, i, uint64(len(m.VolName)))
		i--
		dAtA[i] = 0x3a
	}
	if m.IsLeader {
		i--
		if m.IsLeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.MaxInodeID != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.MaxInodeID))
		i--
		dAtA[i] = 0x28
	}
	if m.Status != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.End != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x18
	}
	if m.Start != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x10
	}
	if m.PartitionID != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.PartitionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MetaNodeDiskInfoPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaNodeDiskInfoPb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaNodeDiskInfoPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MPCount != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.MPCount))
		i--
		dAtA[i] = 0x30
	}
	if m.Status != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if m.UsageRatio != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UsageRatio))))
		i--
		dAtA[i] = 0x25
	}
	if m.Used != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.Used))
		i--
		dAtA[i] = 0x18
	}
	if m.Total != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintHeartbeat(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetaNodeHeartbeatResponsePb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaNodeHeartbeatResponsePb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaNodeHeartbeatResponsePb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintHeartbeat(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.RocksDBDiskInfo) > 0 {
		for iNdEx := len(m.RocksDBDiskInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RocksDBDiskInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHeartbeat(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintHeartbeat(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ProfPort) > 0 {
		i -= len(m.ProfPort)
		copy(dAtA[i:], m.ProfPort)
		i = encodeVarintHeartbeat(dAtA, i, uint64(len(m.ProfPort)))
		i--
		dAtA[i] = 0x32
	}
	if m.Status != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if len(m.MetaPartitionReports) > 0 {
		for iNdEx := len(m.MetaPartitionReports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MetaPartitionReports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintHeartbeat(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Used != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.Used))
		i--
		dAtA[i] = 0x18
	}
	if m.Total != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ZoneName) > 0 {
		i -= len(m.ZoneName)
		copy(dAtA[i:], m.ZoneName)
		i = encodeVarintHeartbeat(dAtA, i, uint64(len(m.ZoneName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeartBeatRequestPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartBeatRequestPb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartBeatRequestPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MasterAddr) > 0 {
		i -= len(m.MasterAddr)
		copy(dAtA[i:], m.MasterAddr)
		i = encodeVarintHeartbeat(dAtA, i, uint64(len(m.MasterAddr)))
		i--
		dAtA[i] = 0x12
	}
	if m.CurrTime != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.CurrTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HeartbeatAdminTaskPb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatAdminTaskPb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartbeatAdminTaskPb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DataNodeResponse != nil {
		{
			size, err := m.DataNodeResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHeartbeat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.MetaNodeResponse != nil {
		{
			size, err := m.MetaNodeResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHeartbeat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHeartbeat(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ReserveResource {
		i--
		if m.ReserveResource {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.SendCount != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.SendCount))
		i--
		dAtA[i] = 0x40
	}
	if m.CreateTime != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.CreateTime))
		i--
		dAtA[i] = 0x38
	}
	if m.SendTime != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.SendTime))
		i--
		dAtA[i] = 0x30
	}
	if m.Status != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if len(m.OperatorAddr) > 0 {
		i -= len(m.OperatorAddr)
		copy(dAtA[i:], m.OperatorAddr)
		i = encodeVarintHeartbeat(dAtA, i, uint64(len(m.OperatorAddr)))
		i--
		dAtA[i] = 0x22
	}
	if m.OpCode != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.OpCode))
		i--
		dAtA[i] = 0x18
	}
	if m.PartitionID != 0 {
		i = encodeVarintHeartbeat(dAtA, i, uint64(m.PartitionID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintHeartbeat(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintHeartbeat(dAtA []byte, offset int, v uint64) int {
	offset -= sovHeartbeat(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PartitionReportPb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VolName)
	if l > 0 {
		n += 1 + l + sovHeartbeat(uint64(l))
	}
	if m.PartitionID != 0 {
		n += 1 + sovHeartbeat(uint64(m.PartitionID))
	}
	if m.PartitionStatus != 0 {
		n += 1 + sovHeartbeat(uint64(m.PartitionStatus))
	}
	if m.Total != 0 {
		n += 1 + sovHeartbeat(uint64(m.Total))
	}
	if m.Used != 0 {
		n += 1 + sovHeartbeat(uint64(m.Used))
	}
	l = len(m.DiskPath)
	if l > 0 {
		n += 1 + l + sovHeartbeat(uint64(l))
	}
	if m.IsLeader {
		n += 2
	}
	if m.ExtentCount != 0 {
		n += 1 + sovHeartbeat(uint64(m.ExtentCount))
	}
	if m.NeedCompare {
		n += 2
	}
	if m.IsLearner {
		n += 2
	}
	if m.LastUpdateTime != 0 {
		n += 1 + sovHeartbeat(uint64(m.LastUpdateTime))
	}
	if m.IsRecover {
		n += 2
	}
	if m.IsSFX {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiskInfoPb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovHeartbeat(uint64(m.Total))
	}
	if m.Used != 0 {
		n += 1 + sovHeartbeat(uint64(m.Used))
	}
	if m.ReservedSpace != 0 {
		n += 1 + sovHeartbeat(uint64(m.ReservedSpace))
	}
	if m.Status != 0 {
		n += 1 + sovHeartbeat(uint64(m.Status))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovHeartbeat(uint64(l))
	}
	if m.UsageRatio != 0 {
		n += 5
	}
	if m.IsSFX {
		n += 2
	}
	if m.PhysicalUsedRatio != 0 {
		n += 1 + sovHeartbeat(uint64(m.PhysicalUsedRatio))
	}
	if m.CompressionRatio != 0 {
		n += 1 + sovHeartbeat(uint64(m.CompressionRatio))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataNodeHeartbeatResponsePb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovHeartbeat(uint64(m.Total))
	}
	if m.Used != 0 {
		n += 1 + sovHeartbeat(uint64(m.Used))
	}
	if m.Available != 0 {
		n += 1 + sovHeartbeat(uint64(m.Available))
	}
	if m.TotalPartitionSize != 0 {
		n += 1 + sovHeartbeat(uint64(m.TotalPartitionSize))
	}
	if m.RemainingCapacity != 0 {
		n += 1 + sovHeartbeat(uint64(m.RemainingCapacity))
	}
	if m.CreatedPartitionCnt != 0 {
		n += 1 + sovHeartbeat(uint64(m.CreatedPartitionCnt))
	}
	if m.MaxCapacity != 0 {
		n += 1 + sovHeartbeat(uint64(m.MaxCapacity))
	}
	l = len(m.HttpPort)
	if l > 0 {
		n += 1 + l + sovHeartbeat(uint64(l))
	}
	l = len(m.ZoneName)
	if l > 0 {
		n += 1 + l + sovHeartbeat(uint64(l))
	}
	if len(m.PartitionReports) > 0 {
		for _, e := range m.PartitionReports {
			l = e.Size()
			n += 1 + l + sovHeartbeat(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovHeartbeat(uint64(m.Status))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovHeartbeat(uint64(l))
	}
	if len(m.BadDisks) > 0 {
		for _, s := range m.BadDisks {
			l = len(s)
			n += 1 + l + sovHeartbeat(uint64(l))
		}
	}
	if len(m.DiskInfos) > 0 {
		for k, v := range m.DiskInfos {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovHeartbeat(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovHeartbeat(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovHeartbeat(uint64(mapEntrySize))
		}
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovHeartbeat(uint64(l))
	}
	if m.Medium != 0 {
		n += 2 + sovHeartbeat(uint64(m.Medium))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetaPartitionReportPb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PartitionID != 0 {
		n += 1 + sovHeartbeat(uint64(m.PartitionID))
	}
	if m.Start != 0 {
		n += 1 + sovHeartbeat(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovHeartbeat(uint64(m.End))
	}
	if m.Status != 0 {
		n += 1 + sovHeartbeat(uint64(m.Status))
	}
	if m.MaxInodeID != 0 {
		n += 1 + sovHeartbeat(uint64(m.MaxInodeID))
	}
	if m.IsLeader {
		n += 2
	}
	l = len(m.VolName)
	if l > 0 {
		n += 1 + l + sovHeartbeat(uint64(l))
	}
	if m.InodeCnt != 0 {
		n += 1 + sovHeartbeat(uint64(m.InodeCnt))
	}
	if m.DentryCnt != 0 {
		n += 1 + sovHeartbeat(uint64(m.DentryCnt))
	}
	if m.DelInodeCnt != 0 {
		n += 1 + sovHeartbeat(uint64(m.DelInodeCnt))
	}
	if m.DelDentryCnt != 0 {
		n += 1 + sovHeartbeat(uint64(m.DelDentryCnt))
	}
	if m.IsLearner {
		n += 2
	}
	if m.ExistMaxInodeID != 0 {
		n += 1 + sovHeartbeat(uint64(m.ExistMaxInodeID))
	}
	if m.StoreMode != 0 {
		n += 1 + sovHeartbeat(uint64(m.StoreMode))
	}
	if m.ApplyId != 0 {
		n += 1 + sovHeartbeat(uint64(m.ApplyId))
	}
	if m.IsRecover {
		n += 3
	}
	if m.AllocatorInUseCnt != 0 {
		n += 2 + sovHeartbeat(uint64(m.AllocatorInUseCnt))
	}
	if m.InodesTotalSize != 0 {
		n += 2 + sovHeartbeat(uint64(m.InodesTotalSize))
	}
	if m.DelInodesTotalSize != 0 {
		n += 2 + sovHeartbeat(uint64(m.DelInodesTotalSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetaNodeDiskInfoPb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovHeartbeat(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovHeartbeat(uint64(m.Total))
	}
	if m.Used != 0 {
		n += 1 + sovHeartbeat(uint64(m.Used))
	}
	if m.UsageRatio != 0 {
		n += 5
	}
	if m.Status != 0 {
		n += 1 + sovHeartbeat(uint64(m.Status))
	}
	if m.MPCount != 0 {
		n += 1 + sovHeartbeat(uint64(m.MPCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetaNodeHeartbeatResponsePb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ZoneName)
	if l > 0 {
		n += 1 + l + sovHeartbeat(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovHeartbeat(uint64(m.Total))
	}
	if m.Used != 0 {
		n += 1 + sovHeartbeat(uint64(m.Used))
	}
	if len(m.MetaPartitionReports) > 0 {
		for _, e := range m.MetaPartitionReports {
			l = e.Size()
			n += 1 + l + sovHeartbeat(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovHeartbeat(uint64(m.Status))
	}
	l = len(m.ProfPort)
	if l > 0 {
		n += 1 + l + sovHeartbeat(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovHeartbeat(uint64(l))
	}
	if len(m.RocksDBDiskInfo) > 0 {
		for _, e := range m.RocksDBDiskInfo {
			l = e.Size()
			n += 1 + l + sovHeartbeat(uint64(l))
		}
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovHeartbeat(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeartBeatRequestPb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CurrTime != 0 {
		n += 1 + sovHeartbeat(uint64(m.CurrTime))
	}
	l = len(m.MasterAddr)
	if l > 0 {
		n += 1 + l + sovHeartbeat(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeartbeatAdminTaskPb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovHeartbeat(uint64(l))
	}
	if m.PartitionID != 0 {
		n += 1 + sovHeartbeat(uint64(m.PartitionID))
	}
	if m.OpCode != 0 {
		n += 1 + sovHeartbeat(uint64(m.OpCode))
	}
	l = len(m.OperatorAddr)
	if l > 0 {
		n += 1 + l + sovHeartbeat(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovHeartbeat(uint64(m.Status))
	}
	if m.SendTime != 0 {
		n += 1 + sovHeartbeat(uint64(m.SendTime))
	}
	if m.CreateTime != 0 {
		n += 1 + sovHeartbeat(uint64(m.CreateTime))
	}
	if m.SendCount != 0 {
		n += 1 + sovHeartbeat(uint64(m.SendCount))
	}
	if m.ReserveResource {
		n += 2
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovHeartbeat(uint64(l))
	}
	if m.MetaNodeResponse != nil {
		l = m.MetaNodeResponse.Size()
		n += 1 + l + sovHeartbeat(uint64(l))
	}
	if m.DataNodeResponse != nil {
		l = m.DataNodeResponse.Size()
		n += 1 + l + sovHeartbeat(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovHeartbeat(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozHeartbeat(x uint64) (n int) {
	return sovHeartbeat(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PartitionReportPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHeartbeat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionReportPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionReportPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionID", wireType)
			}
			m.PartitionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionStatus", wireType)
			}
			m.PartitionStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLeader = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtentCount", wireType)
			}
			m.ExtentCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtentCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedCompare", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedCompare = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLearner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLearner = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateTime", wireType)
			}
			m.LastUpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRecover", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRecover = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSFX", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSFX = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipHeartbeat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskInfoPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHeartbeat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskInfoPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskInfoPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservedSpace", wireType)
			}
			m.ReservedSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReservedSpace |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageRatio", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UsageRatio = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSFX", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSFX = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalUsedRatio", wireType)
			}
			m.PhysicalUsedRatio = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhysicalUsedRatio |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionRatio", wireType)
			}
			m.CompressionRatio = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionRatio |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHeartbeat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataNodeHeartbeatResponsePb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHeartbeat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataNodeHeartbeatResponsePb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataNodeHeartbeatResponsePb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			m.Available = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Available |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPartitionSize", wireType)
			}
			m.TotalPartitionSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPartitionSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingCapacity", wireType)
			}
			m.RemainingCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainingCapacity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedPartitionCnt", wireType)
			}
			m.CreatedPartitionCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedPartitionCnt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCapacity", wireType)
			}
			m.MaxCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCapacity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ZoneName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionReports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionReports = append(m.PartitionReports, &PartitionReportPb{})
			if err := m.PartitionReports[len(m.PartitionReports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadDisks", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BadDisks = append(m.BadDisks, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DiskInfos == nil {
				m.DiskInfos = make(map[string]*DiskInfoPb)
			}
			var mapkey string
			var mapvalue *DiskInfoPb
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHeartbeat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHeartbeat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthHeartbeat
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthHeartbeat
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHeartbeat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthHeartbeat
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthHeartbeat
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DiskInfoPb{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipHeartbeat(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthHeartbeat
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DiskInfos[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Medium", wireType)
			}
			m.Medium = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Medium |= MediumTypePb(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHeartbeat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaPartitionReportPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHeartbeat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaPartitionReportPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaPartitionReportPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionID", wireType)
			}
			m.PartitionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInodeID", wireType)
			}
			m.MaxInodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxInodeID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLeader = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InodeCnt", wireType)
			}
			m.InodeCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InodeCnt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DentryCnt", wireType)
			}
			m.DentryCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DentryCnt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelInodeCnt", wireType)
			}
			m.DelInodeCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelInodeCnt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelDentryCnt", wireType)
			}
			m.DelDentryCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelDentryCnt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLearner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLearner = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistMaxInodeID", wireType)
			}
			m.ExistMaxInodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExistMaxInodeID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreMode", wireType)
			}
			m.StoreMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreMode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyId", wireType)
			}
			m.ApplyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRecover", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRecover = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatorInUseCnt", wireType)
			}
			m.AllocatorInUseCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllocatorInUseCnt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InodesTotalSize", wireType)
			}
			m.InodesTotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InodesTotalSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelInodesTotalSize", wireType)
			}
			m.DelInodesTotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelInodesTotalSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHeartbeat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaNodeDiskInfoPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHeartbeat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaNodeDiskInfoPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaNodeDiskInfoPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageRatio", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UsageRatio = float32(math.Float32frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MPCount", wireType)
			}
			m.MPCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MPCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHeartbeat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaNodeHeartbeatResponsePb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHeartbeat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaNodeHeartbeatResponsePb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaNodeHeartbeatResponsePb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ZoneName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaPartitionReports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaPartitionReports = append(m.MetaPartitionReports, &MetaPartitionReportPb{})
			if err := m.MetaPartitionReports[len(m.MetaPartitionReports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocksDBDiskInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RocksDBDiskInfo = append(m.RocksDBDiskInfo, &MetaNodeDiskInfoPb{})
			if err := m.RocksDBDiskInfo[len(m.RocksDBDiskInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHeartbeat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartBeatRequestPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHeartbeat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartBeatRequestPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartBeatRequestPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrTime", wireType)
			}
			m.CurrTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHeartbeat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatAdminTaskPb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHeartbeat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatAdminTaskPb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatAdminTaskPb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionID", wireType)
			}
			m.PartitionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpCode", wireType)
			}
			m.OpCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendTime", wireType)
			}
			m.SendTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendCount", wireType)
			}
			m.SendCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReserveResource", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReserveResource = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &HeartBeatRequestPb{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaNodeResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetaNodeResponse == nil {
				m.MetaNodeResponse = &MetaNodeHeartbeatResponsePb{}
			}
			if err := m.MetaNodeResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataNodeResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHeartbeat
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataNodeResponse == nil {
				m.DataNodeResponse = &DataNodeHeartbeatResponsePb{}
			}
			if err := m.DataNodeResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHeartbeat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHeartbeat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHeartbeat(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHeartbeat
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHeartbeat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthHeartbeat
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupHeartbeat
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthHeartbeat
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthHeartbeat        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHeartbeat          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupHeartbeat = fmt.Errorf("proto: unexpected end of group")
)
